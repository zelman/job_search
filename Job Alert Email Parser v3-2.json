{
  "name": "Job Alert Email Parser v3",
  "nodes": [
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Route based on email sender - check multiple possible locations\nlet from = $input.item.json.from || $input.item.json.From || '';\n\n// Handle object format (Gmail returns {value: [{address, name}], text, html})\nif (from && typeof from === 'object') {\n  from = from.text || (from.value && from.value[0] && from.value[0].address) || '';\n}\n\n// If not found, check payload.headers (Gmail API format)\nif (!from && $input.item.json.payload && $input.item.json.payload.headers) {\n  const headers = $input.item.json.payload.headers;\n  const fromHeader = headers.find(h => h.name.toLowerCase() === 'from');\n  if (fromHeader) from = fromHeader.value;\n}\n\nconst fromLower = (from || '').toLowerCase();\n\nlet source = 'Other';\nif (fromLower.includes('indeed')) source = 'Indeed';\nelse if (fromLower.includes('linkedin')) source = 'LinkedIn';\nelse if (fromLower.includes('wellfound')) source = 'Wellfound';\nelse if (fromLower.includes('builtin') || fromLower.includes('built-in') || fromLower.includes('built in')) source = 'Built In';\nelse if (fromLower.includes('remotive')) source = 'Remotive';\nelse if (fromLower.includes('himalayas')) source = 'Himalayas';\nelse if (fromLower.includes('welcometothejungle')) source = 'Welcome to the Jungle';\n\nreturn { json: { ...$input.item.json, _source: source } };           "
      },
      "id": "71a95d40-2cbe-4d84-9a76-dca9a7636208",
      "name": "Identify Source",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1856,
        -416
      ]
    },
    {
      "parameters": {
        "jsCode": "// Parse Jobs - Multi-source parser v8 (Fixed Remotive URL parsing for Postmark tracking)\nconst source = $input.item.json._source || 'Other';\n\n// Helper function to decode base64url (Gmail API format)\nconst decodeBase64Url = (data) => {\n  if (!data) return '';\n\n  // If it already has multiple spaces and readable words, it's already decoded\n  if (/\\s{2,}/.test(data) && /[a-z]{4,}\\s+[a-z]{4,}/i.test(data)) {\n    return data;\n  }\n\n  // Only decode if it looks like pure base64 (no spaces in first 100 chars)\n  const sample = data.substring(0, 100);\n  if (!/\\s/.test(sample) && /^[A-Za-z0-9_-]+=*$/.test(sample.replace(/\\s/g, ''))) {\n    try {\n      const cleaned = data.replace(/\\s/g, '');\n      const base64 = cleaned.replace(/-/g, '+').replace(/_/g, '/');\n      const decoded = Buffer.from(base64, 'base64').toString('utf-8');\n      // Verify it decoded to readable text (has letters and spaces)\n      if (/[a-z]{3,}/i.test(decoded) && !/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/.test(decoded)) {\n        return decoded;\n      }\n    } catch (e) {\n      // Decoding failed\n    }\n  }\n\n  return data;\n};\n\n// Helper to strip HTML tags\nconst stripHtml = (html) => {\n  if (!html) return '';\n  return html\n    .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')\n    .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')\n    .replace(/<[^>]+>/g, ' ')\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&#39;/g, \"'\")\n    .replace(/&quot;/g, '\"')\n    .replace(/\\s+/g, ' ')\n    .trim();\n};\n\n// Helper to recursively find text content in MIME parts\nconst extractTextFromParts = (parts) => {\n  if (!parts || !Array.isArray(parts)) return '';\n\n  for (const part of parts) {\n    const mimeType = part.mimeType || '';\n\n    if (mimeType === 'text/plain' && part.body && part.body.data) {\n      return decodeBase64Url(part.body.data);\n    }\n\n    if (mimeType.startsWith('multipart/') && part.parts) {\n      const nested = extractTextFromParts(part.parts);\n      if (nested) return nested;\n    }\n  }\n\n  // Fallback to text/html\n  for (const part of parts) {\n    if (part.mimeType === 'text/html' && part.body && part.body.data) {\n      const html = decodeBase64Url(part.body.data);\n      return stripHtml(html);\n    }\n    if (part.parts) {\n      const nested = extractTextFromParts(part.parts);\n      if (nested) return nested;\n    }\n  }\n\n  return '';\n};\n\n// Helper to extract raw HTML from email (for URL extraction)\nconst extractHtmlFromParts = (parts) => {\n  if (!parts || !Array.isArray(parts)) return '';\n\n  for (const part of parts) {\n    if (part.mimeType === 'text/html' && part.body && part.body.data) {\n      return decodeBase64Url(part.body.data);\n    }\n    if (part.parts) {\n      const nested = extractHtmlFromParts(part.parts);\n      if (nested) return nested;\n    }\n  }\n  return '';\n};\n\n// Try multiple possible locations for email body content\nlet textContent = '';\nlet htmlContent = '';\n\n// 1. Check common field names first (n8n Gmail node simplified output)\nif ($input.item.json.textPlain) {\n  textContent = $input.item.json.textPlain;\n}\nif ($input.item.json.textHtml) {\n  htmlContent = $input.item.json.textHtml;\n} else if ($input.item.json.html) {\n  htmlContent = $input.item.json.html;\n}\nif ($input.item.json.text) {\n  textContent = $input.item.json.text;\n}\n\n// 2. Check Gmail-specific structure: payload\nif ($input.item.json.payload) {\n  const payload = $input.item.json.payload;\n\n  // Extract HTML for URL parsing\n  if (payload.mimeType === 'text/html' && payload.body && payload.body.data) {\n    htmlContent = decodeBase64Url(payload.body.data);\n    if (!textContent) textContent = stripHtml(htmlContent);\n  }\n  else if (payload.parts && payload.parts.length > 0) {\n    if (!htmlContent) htmlContent = extractHtmlFromParts(payload.parts);\n    if (!textContent) textContent = extractTextFromParts(payload.parts);\n  }\n  else if (payload.body && payload.body.data) {\n    if (!textContent) textContent = decodeBase64Url(payload.body.data);\n  }\n}\n\n// 3. Fallback to snippet\nif (!textContent && $input.item.json.snippet) {\n  textContent = $input.item.json.snippet;\n}\n\nconst jobs = [];\n\n// === SOURCE-SPECIFIC PARSERS ===\n\nif (source === 'LinkedIn') {\n  // LinkedIn pattern: Jobs separated by dashed lines, each with \"View job:\" URL\n  const sections = textContent.split(/[-]{10,}/);\n\n  for (const section of sections) {\n    const urlMatch = section.match(/linkedin\\.com\\/(?:comm\\/)?jobs\\/view\\/(\\d+)/);\n    if (!urlMatch) continue;\n\n    const jobId = urlMatch[1];\n    const jobUrl = `https://www.linkedin.com/jobs/view/${jobId}`;\n\n    const textBefore = section.split(/View job/i)[0].trim();\n\n    const cleanText = textBefore\n      .replace(/https?:\\/\\/[^\\s]+/g, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n\n    const parts = cleanText.split(/\\s{2,}|\\n/).map(p => p.trim()).filter(p => p.length > 1);\n\n    const noise = ['high skills match', 'fast growing', 'actively hiring', 'connections', 'posted', 'applicants', 'promoted', 'apply with resume', 'this company is', 'school alum', 'connection', 'top job picks'];\n    const cleanParts = parts.filter(p => !noise.some(n => p.toLowerCase().includes(n)));\n\n    if (cleanParts.length >= 2) {\n      jobs.push({\n        title: cleanParts[0],\n        company: cleanParts[1],\n        location: cleanParts[2] || 'United States',\n        salary: 'Not specified',\n        source: 'LinkedIn',\n        url: jobUrl,\n        jobId: `linkedin-${jobId}`\n      });\n    }\n  }\n}\n\nelse if (source === 'Himalayas') {\n  const seenJobs = new Set();\n\n  // URL-decode the content first to handle encoded URLs in tracking links\n  let decodedContent = textContent;\n  try {\n    // Decode multiple times in case of double-encoding\n    decodedContent = decodeURIComponent(decodeURIComponent(textContent));\n  } catch (e) {\n    try {\n      decodedContent = decodeURIComponent(textContent);\n    } catch (e2) {\n      // Keep original if decoding fails\n    }\n  }\n\n  // Handle URL-based format (tracking links from email)\n  const urlPattern = /himalayas\\.app\\/companies\\/([^\\/]+)\\/jobs\\/([^\\s\\/\\]\"&<>]+)/gi;\n  let urlMatch;\n\n  while ((urlMatch = urlPattern.exec(decodedContent)) !== null) {\n    const companySlug = urlMatch[1];\n    const titleSlug = urlMatch[2];\n\n    // Convert slugs to readable names\n    const company = companySlug\n      .split('-')\n      .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n      .join(' ');\n\n    const title = titleSlug\n      .replace(/-\\d+$/, '') // Remove trailing ID numbers like \"-9491544946\"\n      .split('-')\n      .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n      .join(' ');\n\n    if (title.length < 3 || company.length < 2) continue;\n\n    const key = `${title.toLowerCase()}-${company.toLowerCase()}`;\n    if (seenJobs.has(key)) continue;\n    seenJobs.add(key);\n\n    jobs.push({\n      title: title,\n      company: company,\n      location: 'Remote',\n      salary: 'Not specified',\n      source: 'Himalayas',\n      url: `https://himalayas.app/companies/${companySlug}/jobs/${titleSlug}`,\n      jobId: `himalayas-${Date.now()}-${jobs.length}`\n    });\n  }\n\n  // FALLBACK 1: Text-based pattern for \"Your top matches\" format\n  if (jobs.length === 0) {\n    const matchSection = textContent.match(/Your top matches for[^]*?(\\d{4})\\s*([\\s\\S]*?)(?:See your matches|Sponsored jobs|Top jobs from)/i);\n\n    if (matchSection) {\n      const jobText = matchSection[2].trim();\n\n      const jobPattern = /([A-Za-z][A-Za-z\\s&\\-,]+(?:Manager|Director|Head|Lead|Engineer|Representative|Specialist|Coordinator|Analyst|Advisor|Consultant|Success|Support|Operations)(?:\\s*\\([^)]+\\))?)\\s+([A-Z][A-Za-z0-9\\s&]+?)(?=\\s+[A-Z][a-z]+\\s+(?:Manager|Director|Head|Lead|Engineer|Success|Support)|$)/gi;\n\n      let match;\n      while ((match = jobPattern.exec(jobText)) !== null) {\n        let title = match[1].trim();\n        let company = match[2].trim();\n\n        company = company.replace(/\\s+(Customer|Client|Implementation|Technical|Product|Senior|Junior|Lead)\\s*$/i, '').trim();\n\n        if (title.length < 5 || company.length < 2) continue;\n\n        const key = `${title.toLowerCase()}-${company.toLowerCase()}`;\n        if (seenJobs.has(key)) continue;\n        seenJobs.add(key);\n\n        jobs.push({\n          title: title,\n          company: company,\n          location: 'Remote',\n          salary: 'Not specified',\n          source: 'Himalayas',\n          url: 'https://himalayas.app/jobs',\n          jobId: `himalayas-${Date.now()}-${jobs.length}`\n        });\n      }\n    }\n  }\n\n  // FALLBACK 2: Line-by-line parsing\n  if (jobs.length === 0) {\n    const lines = textContent.split(/\\n/).map(l => l.trim()).filter(l => l.length > 3);\n    const titleKeywords = ['manager', 'director', 'head', 'lead', 'engineer', 'support', 'success',\n                           'specialist', 'coordinator', 'analyst', 'consultant', 'onboarding', 'implementation'];\n\n    for (let i = 0; i < lines.length - 1; i++) {\n      const line = lines[i];\n      const nextLine = lines[i + 1];\n\n      if (titleKeywords.some(k => line.toLowerCase().includes(k))) {\n        if (/^[A-Z]/.test(nextLine) &&\n            nextLine.length < 50 &&\n            !titleKeywords.some(k => nextLine.toLowerCase().includes(k)) &&\n            !nextLine.toLowerCase().includes('your') &&\n            !nextLine.toLowerCase().includes('email') &&\n            !nextLine.toLowerCase().includes('unsubscribe')) {\n\n          const key = `${line.toLowerCase()}-${nextLine.toLowerCase()}`;\n          if (seenJobs.has(key)) continue;\n          seenJobs.add(key);\n\n          jobs.push({\n            title: line,\n            company: nextLine,\n            location: 'Remote',\n            salary: 'Not specified',\n            source: 'Himalayas',\n            url: 'https://himalayas.app/jobs',\n            jobId: `himalayas-${Date.now()}-${i}`\n          });\n          i++;\n        }\n      }\n    }\n  }\n}\n\nelse if (source === 'Wellfound') {\n  // Wellfound format: \"Title Company / Size | Location | exp | Type\"\n\n  // First extract job URLs for linking\n  const urlMatches = [...textContent.matchAll(/wellfound\\.com\\/jobs\\?job_listing_slug=(\\d+[^\\s>\"'\\]]*)/gi)];\n  const jobSlugs = urlMatches.map(m => m[1]);\n\n  // Pattern for Wellfound job listings\n  const jobPattern = /([A-Za-z][A-Za-z\\s&\\-,\\(\\)]+?(?:Manager|Director|Specialist|Associate|Coordinator|Analyst|Engineer|Representative|Support|Success)(?:[A-Za-z\\s&\\-,\\(\\)]*?))\\s+([A-Z][A-Za-z0-9\\s&\\.\\-']+?)\\s*\\/\\s*(\\d+[-‚Äì]\\d+|\\d+\\+?)\\s*Employees/gi;\n\n  let match;\n  let index = 0;\n  while ((match = jobPattern.exec(textContent)) !== null) {\n    const title = match[1].trim();\n    const company = match[2].trim();\n    const size = match[3];\n\n    // Extract location from text after the match\n    const afterMatch = textContent.substring(match.index + match[0].length, match.index + match[0].length + 100);\n    const locationMatch = afterMatch.match(/\\|\\s*([^|]+?)(?:\\s*\\||$)/);\n    const location = locationMatch ? locationMatch[1].trim() : 'Remote';\n\n    jobs.push({\n      title: title,\n      company: company,\n      location: location,\n      salary: 'Not specified',\n      source: 'Wellfound',\n      url: jobSlugs[index] ? `https://wellfound.com/jobs?job_listing_slug=${jobSlugs[index]}` : 'https://wellfound.com',\n      jobId: jobSlugs[index] ? `wellfound-${jobSlugs[index].split('-')[0]}` : `wellfound-${Date.now()}-${index}`,\n      _companySize: `${size} Employees`\n    });\n    index++;\n  }\n}\n\nelse if (source === 'Built In') {\n  // Built In format: \"Company Title Location\"\n\n  const titleKeywords = ['manager', 'director', 'head', 'lead', 'vp', 'engineer', 'specialist', 'coordinator', 'representative', 'support', 'success'];\n\n  // Try \"at\" pattern first\n  const atPattern = /([A-Za-z\\s,\\/&]+(?:Support|Success|Director|Manager|Head|VP|Lead|Engineer|Representative|Specialist)[A-Za-z\\s,\\/&]*)\\s+at\\s+([A-Za-z0-9\\s&.,'\\\\-]+?)(?:\\s+in\\s+([A-Za-z\\s,]+?))?(?:\\n|$)/gi;\n\n  let match;\n  while ((match = atPattern.exec(textContent)) !== null) {\n    jobs.push({\n      title: match[1].trim(),\n      company: match[2].trim(),\n      location: match[3] ? match[3].trim() : 'Not specified',\n      salary: 'Not specified',\n      source: 'Built In',\n      url: 'https://builtin.com/jobs',\n      jobId: `builtin-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n    });\n  }\n\n  // Fallback: Look for \"Company Title Location\" pattern in Job Preferences section\n  if (jobs.length === 0) {\n    const prefSection = textContent.match(/Job Preferences[\\s\\S]*?Get More/i);\n    if (prefSection) {\n      const section = prefSection[0];\n      const pattern = /([A-Z][A-Za-z0-9\\s&.]+?)\\s+((?:Manager|Director|Head|VP|Lead|Specialist|Coordinator|Engineer|Representative)[A-Za-z\\s,]*)\\s+(Remote[^A-Z]*|[A-Z][a-z]+(?:,\\s*[A-Z]{2})?)/gi;\n\n      while ((match = pattern.exec(section)) !== null) {\n        const company = match[1].trim();\n        const title = match[2].trim();\n        const location = match[3].trim();\n\n        if (company.length > 1 && title.length > 5) {\n          jobs.push({\n            title: title,\n            company: company,\n            location: location || 'Not specified',\n            salary: 'Not specified',\n            source: 'Built In',\n            url: 'https://builtin.com/jobs',\n            jobId: `builtin-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n          });\n        }\n      }\n    }\n  }\n}\n\nelse if (source === 'Remotive') {\n  // Remotive emails use Postmark tracking URLs containing real job URLs\n  // Format: track.pstmrk.it/3s/{URL-ENCODED-JOB-URL}/eHy2/{tracking}\n  // Structure: <li>...<a href=\"tracking-url\"><span>Title</span> at <span>Company</span></a> &#x1F4CD; Location</li>\n\n  let searchContent = htmlContent || textContent;\n\n  // Decode quoted-printable encoding (=XX hex codes, =\\n soft line breaks)\n  searchContent = searchContent\n    .replace(/=\\r?\\n/g, '')\n    .replace(/=([0-9A-Fa-f]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));\n\n  // Extract each <li> block which contains one job\n  const liPattern = /<li[^>]*>([\\s\\S]*?)<\\/li>/gi;\n  let liMatch;\n\n  while ((liMatch = liPattern.exec(searchContent)) !== null) {\n    const liContent = liMatch[1];\n\n    // Extract tracking URL from this <li>\n    const urlMatch = liContent.match(/href=[\"']https?:\\/\\/track\\.pstmrk\\.it\\/3s\\/([^\\/]+(?:%2F[^\\/]+)*)\\/eHy2/i);\n    if (!urlMatch) continue;\n\n    const encodedUrl = urlMatch[1];\n\n    // Decode the job URL\n    let jobUrl;\n    try {\n      jobUrl = 'https://' + decodeURIComponent(encodedUrl);\n    } catch (e) {\n      jobUrl = 'https://' + encodedUrl.replace(/%2F/gi, '/').replace(/%3A/gi, ':');\n    }\n\n    // Skip non-job URLs\n    if (jobUrl.includes('remotive.com') && !jobUrl.includes('remote-jobs/')) continue;\n    if (jobUrl.includes('linkedin.com/company')) continue;\n    if (jobUrl.includes('twitter.com')) continue;\n    if (jobUrl.includes('unsubscribe')) continue;\n\n    // Extract title: <span ...>Title</span>\n    const titleMatch = liContent.match(/<span[^>]*font-weight:\\s*bold[^>]*>([^<]+)<\\/span>/i);\n    const title = titleMatch ? titleMatch[1].trim() : '';\n\n    // Extract company: at <span ...>Company</span>\n    const companyMatch = liContent.match(/at\\s*<span[^>]*>([^<]+)<\\/span>/i);\n    const company = companyMatch ? companyMatch[1].trim() : '';\n\n    // Extract location: &#x1F4CD; Location or üìç Location\n    const locationMatch = liContent.match(/(?:&#x1F4CD;|\\u{1F4CD})\\s*([A-Za-z\\s,]+)/iu);\n    const location = locationMatch ? locationMatch[1].trim() : 'Remote';\n\n    if (title && company) {\n      jobs.push({\n        title: title,\n        company: company,\n        location: location,\n        salary: 'Not specified',\n        source: 'Remotive',\n        url: jobUrl,\n        jobId: `remotive-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n      });\n    }\n  }\n\n  // Fallback: If no <li> matches, try text-based pattern\n  if (jobs.length === 0) {\n    const textPattern = /([A-Za-z][A-Za-z\\s,\\/&\\-]+?(?:Manager|Director|Head|VP|Lead|Engineer|Specialist|Coordinator|Analyst|Representative|Support|Success)[A-Za-z\\s,\\/&]*)\\s+at\\s+([A-Za-z0-9][A-Za-z0-9\\s&.,'\\\\-]+?)(?:\\s*\\u{1F4CD}\\s*([A-Za-z\\s,]+))?(?:\\s|$|Looking)/giu;\n\n    let match;\n    while ((match = textPattern.exec(textContent)) !== null) {\n      jobs.push({\n        title: match[1].trim(),\n        company: match[2].trim(),\n        location: match[3] ? match[3].trim() : 'Remote',\n        salary: 'Not specified',\n        source: 'Remotive',\n        url: 'https://remotive.com/remote-jobs',\n        jobId: `remotive-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n      });\n    }\n  }\n}\n\nelse if (source === 'Indeed') {\n  // Extract Indeed job URLs first\n  const indeedUrls = [];\n  const searchContent = htmlContent || textContent;\n\n  // Pattern for Indeed job URLs (various formats)\n  const indeedUrlPattern = /https?:\\/\\/(?:[a-z]+\\.)?indeed\\.com\\/(?:viewjob\\?|rc\\/clk\\?|jobs\\?|job\\/)[^\\s\"'<>]+/gi;\n  let urlMatch;\n  while ((urlMatch = indeedUrlPattern.exec(searchContent)) !== null) {\n    indeedUrls.push(urlMatch[0].replace(/&amp;/g, '&'));\n  }\n\n  // Also check for shortened/tracking URLs\n  const trackingPattern = /to\\.indeed\\.com\\/[a-zA-Z0-9]+/gi;\n  while ((urlMatch = trackingPattern.exec(searchContent)) !== null) {\n    indeedUrls.push(`https://${urlMatch[0]}`);\n  }\n\n  const jobPattern = /([A-Za-z\\s,\\/&]+(?:Support|Success|Director|Manager|Head|VP|Lead|Engineer|Representative|Specialist)[A-Za-z\\s,\\/&]*)\\s+at\\s+([A-Za-z0-9\\s&.,'\\\\-]+?)(?:\\s*[-‚Äì]\\s*|\\s*\\n|\\s*$)/gi;\n\n  let match;\n  let jobIndex = 0;\n  while ((match = jobPattern.exec(textContent)) !== null) {\n    const salaryMatch = textContent.substring(match.index, match.index + 200).match(/\\$[\\d,]+(?:\\s*[-‚Äì]\\s*\\$[\\d,]+)?(?:\\s*(?:\\/|per|a)\\s*(?:year|yr|hour|hr|month))?/i);\n\n    jobs.push({\n      title: match[1].trim(),\n      company: match[2].trim(),\n      location: 'Not specified',\n      salary: salaryMatch ? salaryMatch[0].trim() : 'Not specified',\n      source: 'Indeed',\n      url: indeedUrls[jobIndex] || 'https://indeed.com',\n      jobId: `indeed-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n    });\n    jobIndex++;\n  }\n}\n\nelse if (source === 'Welcome to the Jungle') {\n  const salaryPattern = /Salary:\\s*\\$[\\d,]+(?:\\s*[-‚Äì]\\s*\\$?[\\d,]+)?K?/gi;\n  const salaryMatches = [...textContent.matchAll(salaryPattern)];\n\n  const titleKeywords = ['director', 'manager', 'head', 'lead', 'vp', 'vice president', 'chief', 'support', 'success', 'customer', 'experience', 'representative', 'specialist', 'engineer'];\n\n  for (let i = 0; i < salaryMatches.length; i++) {\n    const salaryMatch = salaryMatches[i];\n    const salaryText = salaryMatch[0];\n    const salaryIndex = salaryMatch.index;\n\n    const prevIndex = i > 0 ? salaryMatches[i-1].index + salaryMatches[i-1][0].length : 0;\n    const textBefore = textContent.substring(prevIndex, salaryIndex);\n\n    const lines = textBefore.split(/\\n|\\r|(?:\\s{3,})/).map(l => l.trim()).filter(l => l.length > 2);\n\n    let title = '';\n    let company = '';\n\n    for (let j = lines.length - 1; j >= 0; j--) {\n      const line = lines[j];\n      const lineLower = line.toLowerCase();\n\n      if (line.length > 80) continue;\n      if (lineLower.includes('click here') || lineLower.includes('unsubscribe')) continue;\n\n      if (!title && titleKeywords.some(k => lineLower.includes(k))) {\n        title = line;\n      } else if (title && !company && line.length < 40) {\n        company = line;\n        break;\n      }\n    }\n\n    if (title && company) {\n      jobs.push({\n        title: title,\n        company: company,\n        location: 'Not specified',\n        salary: salaryText.replace('Salary:', '').trim(),\n        source: 'Welcome to the Jungle',\n        url: 'https://www.welcometothejungle.com',\n        jobId: `wttj-${Date.now()}-${i}`\n      });\n    }\n  }\n}\n\nelse {\n  // Generic parser for unknown sources\n  const atPattern = /([A-Za-z\\s,\\/&]+(?:Support|Success|Director|Manager|Head|VP|Lead|Engineer)[A-Za-z\\s,\\/&]*)\\s+at\\s+([A-Za-z0-9\\s&.,'\\\\-]+)/gi;\n  let match;\n  while ((match = atPattern.exec(textContent)) !== null) {\n    jobs.push({\n      title: match[1].trim(),\n      company: match[2].trim(),\n      location: 'Not specified',\n      salary: 'Not specified',\n      source: source,\n      url: '',\n      jobId: `other-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n    });\n  }\n}\n\n// Deduplicate jobs by title+company\nconst seen = new Set();\nconst uniqueJobs = jobs.filter(job => {\n  const key = `${job.title.toLowerCase()}-${job.company.toLowerCase()}`;\n  if (seen.has(key)) return false;\n  seen.add(key);\n  return true;\n});\n\n// Return parsed jobs or flag no jobs found\nif (uniqueJobs.length === 0) {\n  return [{ json: { _noJobs: true, _source: source, _rawText: textContent.substring(0, 500) } }];\n}\n\n// Add date found to all jobs and return\nreturn uniqueJobs.map(job => ({\n  json: {\n    ...job,\n    _dateFound: new Date().toISOString().split('T')[0]\n  }\n}));"
      },
      "id": "f6fb4efd-ecc4-4d31-b1e8-ba8b3f252699",
      "name": "Parse Jobs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1632,
        -416
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json._noJobs }}",
              "operation": "notEqual",
              "value2": true
            }
          ]
        }
      },
      "id": "a0386dbd-bbe6-4799-816e-1b6e3984a028",
      "name": "Has Jobs",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -1408,
        -416
      ],
      "executeOnce": false
    },
    {
      "parameters": {
        "authentication": "airtableTokenApi",
        "operation": "list",
        "application": "appFEzXvPWvRtXgRY",
        "table": "tbl6ZV2rHjWz56pP3",
        "additionalOptions": {
          "filterByFormula": "=AND({Job Title}=\"{{ $json.title }}\", {Company}=\"{{ $json.company }}\")"
        }
      },
      "id": "e4794e44-6168-41c9-83d8-c033fcbd39c7",
      "name": "Check Duplicate",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 1,
      "position": [
        -2304,
        -688
      ],
      "alwaysOutputData": true,
      "credentials": {
        "airtableTokenApi": {
          "id": "sempBDy7tuv1mA6y",
          "name": "Airtable Personal Access Token account"
        }
      }
    },
    {
      "parameters": {
        "authentication": "airtableTokenApi",
        "operation": "append",
        "application": "appFEzXvPWvRtXgRY",
        "table": "tbl6ZV2rHjWz56pP3",
        "options": {}
      },
      "id": "3d21cc2b-da2f-4e29-874e-0da22e35de60",
      "name": "Add to Airtable",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 1,
      "position": [
        -736,
        -224
      ],
      "credentials": {
        "airtableTokenApi": {
          "id": "sempBDy7tuv1mA6y",
          "name": "Airtable Personal Access Token account"
        }
      }
    },
    {
      "parameters": {},
      "id": "cb1738a1-aaee-4499-833e-b66b9f270add",
      "name": "Skip Duplicate",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -2304,
        48
      ]
    },
    {
      "parameters": {},
      "id": "9b23e798-57a0-49cd-8e38-98ca836c7fcd",
      "name": "No Jobs Found",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -1184,
        -464
      ]
    },
    {
      "parameters": {
        "jsCode": "// Transform field names to match Airtable exactly\nreturn $input.all().map(item => ({\n  json: {\n    \"Job Title\": item.json.title,\n    \"Company\": item.json.company,\n    \"Location\": item.json.location,\n    \"Source\": item.json.source,\n    \"Job URL\": item.json.url,\n    \"Job ID\": item.json.jobId,\n    \"Salary Info\": item.json.salary,\n    \"Date Found\": item.json._dateFound,\n    \"Review Status\": \"New\"\n  }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -960,
        -224
      ],
      "id": "2bfe51ad-db26-409f-a152-df4184505056",
      "name": "Map Fields for Airtable"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {
          "includeUnpaired": true
        }
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -2080,
        -688
      ],
      "id": "22dad795-1adc-49e0-96cf-890a9ff75ed3",
      "name": "Merge"
    },
    {
      "parameters": {
        "operation": "getAll",
        "returnAll": true,
        "simple": false,
        "filters": {
          "q": "is:unread in:inbox from:(jobs-listings@linkedin.com OR jobalerts-noreply@linkedin.com OR jobs-noreply@linkedin.com OR builtin.com OR wellfound.com OR himalayas.app OR remotive.com OR welcometothejungle.com) newer_than:21d"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [
        -2080,
        -416
      ],
      "id": "12b46d30-8170-49aa-adf7-9fdcba3ab327",
      "name": "Get many messages",
      "webhookId": "46595c63-cee2-41ff-834e-8114edf3d651",
      "credentials": {
        "gmailOAuth2": {
          "id": "vUMmpPTSbHvfz72M",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.3,
      "position": [
        -2304,
        -416
      ],
      "id": "c858cdb6-ed8a-4834-a20f-ee17efb13799",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "operation": "addLabels",
        "messageId": "={{ $('Get many messages').item.json.id }}",
        "labelIds": [
          "Label_3146569228785124450"
        ]
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [
        -512,
        -224
      ],
      "id": "040a7872-484b-41be-a763-034418f062f6",
      "name": "Add label to message",
      "webhookId": "a29818cc-9d22-40cb-ad01-47c3f481b26c",
      "credentials": {
        "gmailOAuth2": {
          "id": "vUMmpPTSbHvfz72M",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "value": "appFEzXvPWvRtXgRY",
          "mode": "list",
          "cachedResultName": "Job search",
          "cachedResultUrl": "https://airtable.com/appFEzXvPWvRtXgRY"
        },
        "table": {
          "__rl": true,
          "value": "tbl6ZV2rHjWz56pP3",
          "mode": "list",
          "cachedResultName": "Job Listings",
          "cachedResultUrl": "https://airtable.com/appFEzXvPWvRtXgRY/tbl6ZV2rHjWz56pP3"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        -1408,
        -176
      ],
      "id": "ebf4cca2-69c9-460c-bb37-7b12dd7a21bb",
      "name": "Search records",
      "credentials": {
        "airtableTokenApi": {
          "id": "sempBDy7tuv1mA6y",
          "name": "Airtable Personal Access Token account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get existing records from Airtable (Input 1)\nconst existingRecords = $input.all(1);\nconst existingUrls = new Set(\n  existingRecords.map(item => item.json.fields?.[\"Job URL\"] || item.json[\"Job URL\"])\n);\nconst existingKeys = new Set(\n  existingRecords.map(item => {\n    const t = (item.json.fields?.Title || item.json.Title || \"\").toLowerCase().trim();\n    const c = (item.json.fields?.Company || item.json.Company || \"\").toLowerCase().trim();\n    return t + \"|\" + c;\n  })\n);\n\n// Get new jobs (Input 0)\nconst newJobs = $input.all(0);\nconst results = [];\n\nfor (const job of newJobs) {\n  let url = job.json.url || job.json[\"Job URL\"] || \"\";\n  let title = job.json.title || job.json.Title || \"\";\n  let company = job.json.company || job.json.Company || \"\";\n  const html = job.json.html || job.json.body || job.json.text || \"\";\n\n  // Extract real URL from Remotive tracking links\n  if (url.includes(\"track.pstmrk.it/3s/\")) {\n    const match = url.match(/track\\.pstmrk\\.it\\/3s\\/([^\\/]+)/);\n    if (match) {\n      url = \"https://\" + decodeURIComponent(match[1]);\n    }\n  }\n\n  // If URL is generic remotive.com, try to parse from HTML\n  if (url.includes(\"remotive.com/remote-jobs\") && !url.includes(\"remotive.com/remote-jobs/\") && html) {\n    const regex = /<a href=[\"'][^\"']*track\\.pstmrk\\.it\\/3s\\/([^\\/]+)[^\"']*[\"'][^>]*>[\\s\\S]*?<span[^>]*>([^<]+)<\\/span>\\s*at\\s*<span[^>]*>([^<]+)<\\/span>/gi;\n    let m;\n    while ((m = regex.exec(html)) !== null) {\n      const encodedUrl = m[1];\n      const parsedTitle = m[2].trim();\n      const parsedCompany = m[3].trim();\n      const parsedUrl = \"https://\" + decodeURIComponent(encodedUrl);\n      const key = parsedTitle.toLowerCase() + \"|\" + parsedCompany.toLowerCase();\n\n      if (!existingUrls.has(parsedUrl) && !existingKeys.has(key)) {\n        existingUrls.add(parsedUrl);\n        existingKeys.add(key);\n        results.push({\n          json: {\n            Title: parsedTitle,\n            Company: parsedCompany,\n            \"Job URL\": parsedUrl,\n            Source: \"Remotive\"\n          }\n        });\n      }\n    }\n    continue;\n  }\n\n  // Standard dedup check\n  const key = title.toLowerCase().trim() + \"|\" + company.toLowerCase().trim();\n  if (!existingUrls.has(url) && !existingKeys.has(key)) {\n    existingUrls.add(url);\n    existingKeys.add(key);\n    results.push({\n      json: {\n        ...job.json,\n        \"Job URL\": url\n      }\n    });\n  }\n}\n\nreturn results.length ? results : [{ json: { _empty: true } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1184,
        -224
      ],
      "id": "6f2b2eb2-c6b9-47d2-8c3a-b432aadb1bb4",
      "name": "Code in JavaScript"
    }
  ],
  "pinData": {},
  "connections": {
    "Identify Source": {
      "main": [
        [
          {
            "node": "Parse Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Jobs": {
      "main": [
        [
          {
            "node": "Has Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Jobs": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Jobs Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Duplicate": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Map Fields for Airtable": {
      "main": [
        [
          {
            "node": "Add to Airtable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        []
      ]
    },
    "Get many messages": {
      "main": [
        [
          {
            "node": "Identify Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Get many messages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add to Airtable": {
      "main": [
        [
          {
            "node": "Add label to message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search records": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "Map Fields for Airtable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "timeSavedMode": "fixed",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": true
  },
  "versionId": "e70726e2-ef3f-416c-8180-f8ac61b7bace",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "a6a425099b9f9cd9abf3e131a46fe3b1ceb58f2f047bc24ddb7c77d018810088"
  },
  "id": "x54NNk1Mw7LNhX9o",
  "tags": []
}