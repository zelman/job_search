{
  "name": "Job Alert Email Parser v3-14",
  "nodes": [
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Route based on email sender - reference original email data from Get many messages\nconst emailData = $('Get many messages').item.json;\nlet from = emailData.from || emailData.From || '';\n\n// Handle object format (Gmail returns {value: [{address, name}], text, html})\nif (from && typeof from === 'object') {\n  from = from.text || (from.value && from.value[0] && from.value[0].address) || '';\n}\n\n// If not found, check payload.headers (Gmail API format)\nif (!from && emailData.payload && emailData.payload.headers) {\n  const headers = emailData.payload.headers;\n  const fromHeader = headers.find(h => h.name.toLowerCase() === 'from');\n  if (fromHeader) from = fromHeader.value;\n}\n\nconst fromLower = (from || '').toLowerCase();\n\nlet source = 'Other';\nif (fromLower.includes('indeed')) source = 'Indeed';\nelse if (fromLower.includes('linkedin')) source = 'LinkedIn';\nelse if (fromLower.includes('wellfound')) source = 'Wellfound';\nelse if (fromLower.includes('builtin') || fromLower.includes('built-in') || fromLower.includes('built in')) source = 'Built In';\nelse if (fromLower.includes('remotive')) source = 'Remotive';\nelse if (fromLower.includes('himalayas')) source = 'Himalayas';\nelse if (fromLower.includes('welcometothejungle')) source = 'Welcome to the Jungle';\nelse if (fromLower.includes('jobright')) source = 'Jobright';\nelse if (fromLower.includes('careers-noreply@google.com') || fromLower.includes('google.com/about/careers')) source = 'Google Careers';\n\nreturn { json: { ...emailData, _source: source } };"
      },
      "id": "71a95d40-2cbe-4d84-9a76-dca9a7636208",
      "name": "Identify Source",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1856,
        -416
      ]
    },
    {
      "parameters": {
        "jsCode": "// Parse Jobs - Multi-source parser v9 (Run Once for All Items mode)\n// Process all emails and collect all jobs into one output array\n\nconst allEmails = $input.all();\nconst allJobs = [];\n\n// Helper function to decode base64url (Gmail API format)\nconst decodeBase64Url = (data) => {\n  if (!data) return '';\n  if (/\\s{2,}/.test(data) && /[a-z]{4,}\\s+[a-z]{4,}/i.test(data)) return data;\n  const sample = data.substring(0, 100);\n  if (!/\\s/.test(sample) && /^[A-Za-z0-9_-]+=*$/.test(sample.replace(/\\s/g, ''))) {\n    try {\n      const cleaned = data.replace(/\\s/g, '');\n      const base64 = cleaned.replace(/-/g, '+').replace(/_/g, '/');\n      const decoded = Buffer.from(base64, 'base64').toString('utf-8');\n      if (/[a-z]{3,}/i.test(decoded) && !/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/.test(decoded)) return decoded;\n    } catch (e) {}\n  }\n  return data;\n};\n\n// Helper to strip HTML tags\nconst stripHtml = (html) => {\n  if (!html) return '';\n  return html\n    .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')\n    .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')\n    .replace(/<[^>]+>/g, ' ')\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&#39;/g, \"'\")\n    .replace(/&quot;/g, '\"')\n    .replace(/\\s+/g, ' ')\n    .trim();\n};\n\n// Helper to recursively find text content in MIME parts\nconst extractTextFromParts = (parts) => {\n  if (!parts || !Array.isArray(parts)) return '';\n\n  for (const part of parts) {\n    const mimeType = part.mimeType || '';\n\n    if (mimeType === 'text/plain' && part.body && part.body.data) {\n      return decodeBase64Url(part.body.data);\n    }\n\n    if (mimeType.startsWith('multipart/') && part.parts) {\n      const nested = extractTextFromParts(part.parts);\n      if (nested) return nested;\n    }\n  }\n\n  // Fallback to text/html\n  for (const part of parts) {\n    if (part.mimeType === 'text/html' && part.body && part.body.data) {\n      const html = decodeBase64Url(part.body.data);\n      return stripHtml(html);\n    }\n    if (part.parts) {\n      const nested = extractTextFromParts(part.parts);\n      if (nested) return nested;\n    }\n  }\n\n  return '';\n};\n\n// Helper to extract raw HTML from email (for URL extraction)\nconst extractHtmlFromParts = (parts) => {\n  if (!parts || !Array.isArray(parts)) return '';\n\n  for (const part of parts) {\n    if (part.mimeType === 'text/html' && part.body && part.body.data) {\n      return decodeBase64Url(part.body.data);\n    }\n    if (part.parts) {\n      const nested = extractHtmlFromParts(part.parts);\n      if (nested) return nested;\n    }\n  }\n  return '';\n};\n\n// Process each email\nfor (const emailItem of allEmails) {\n  const email = emailItem.json;\n  const source = email._source || 'Other';\n  \n  // Try multiple possible locations for email body content\n  let textContent = '';\n  let htmlContent = '';\n\n  // 1. Check common field names first (n8n Gmail node simplified output)\n  if (email.textPlain) textContent = email.textPlain;\n  if (email.textHtml) htmlContent = email.textHtml;\n  else if (email.html) htmlContent = email.html;\n  if (email.text) textContent = email.text;\n\n  // 2. Check Gmail-specific structure: payload\n  if (email.payload) {\n    const payload = email.payload;\n    if (payload.mimeType === 'text/html' && payload.body && payload.body.data) {\n      htmlContent = decodeBase64Url(payload.body.data);\n      if (!textContent) textContent = stripHtml(htmlContent);\n    }\n    else if (payload.parts && payload.parts.length > 0) {\n      if (!htmlContent) htmlContent = extractHtmlFromParts(payload.parts);\n      if (!textContent) textContent = extractTextFromParts(payload.parts);\n    }\n    else if (payload.body && payload.body.data) {\n      if (!textContent) textContent = decodeBase64Url(payload.body.data);\n    }\n  }\n\n  // 3. Fallback to snippet\n  if (!textContent && email.snippet) textContent = email.snippet;\n\n  // 4. Final fallback: convert HTML to text if still no text content\n  if (!textContent && htmlContent) textContent = stripHtml(htmlContent);\n\n  const jobs = [];\n  let parserError = null;\n\n// === SOURCE-SPECIFIC PARSERS ===\n\ntry {\n\nif (source === 'LinkedIn') {\n  // LinkedIn pattern: Jobs separated by dashed lines, each with \"View job:\" URL\n  const sections = textContent.split(/[-]{10,}/);\n\n  for (const section of sections) {\n    const urlMatch = section.match(/linkedin\\.com\\/(?:comm\\/)?jobs\\/view\\/(\\d+)/);\n    if (!urlMatch) continue;\n\n    const jobId = urlMatch[1];\n    const jobUrl = `https://www.linkedin.com/jobs/view/${jobId}`;\n\n    const textBefore = section.split(/View job/i)[0].trim();\n\n    // Split by newlines FIRST, then clean each line (don't collapse newlines before splitting)\n    const parts = textBefore\n      .replace(/https?:\\/\\/[^\\s]+/g, '')  // Remove URLs\n      .split(/\\n/)                          // Split by newlines\n      .map(p => p.replace(/\\s+/g, ' ').trim())  // Clean each line\n      .filter(p => p.length > 1);\n\n    const noise = ['high skills match', 'fast growing', 'actively hiring', 'connections', 'posted', 'applicants', 'promoted', 'apply with resume', 'this company is', 'school alum', 'connection', 'top job picks', 'your job alert', 'new jobs match your preferences', 'match your preferences'];\n    const cleanParts = parts.filter(p => !noise.some(n => p.toLowerCase().includes(n)));\n\n    if (cleanParts.length >= 2) {\n      jobs.push({\n        title: cleanParts[0],\n        company: cleanParts[1],\n        location: cleanParts[2] || 'United States',\n        salary: 'Not specified',\n        source: 'LinkedIn',\n        url: jobUrl,\n        jobId: `linkedin-${jobId}`\n      });\n    }\n  }\n}\n\nelse if (source === 'Himalayas') {\n  const seenJobs = new Set();\n\n  // URL-decode the content first to handle encoded URLs in tracking links\n  let decodedContent = textContent;\n  try {\n    // Decode multiple times in case of double-encoding\n    decodedContent = decodeURIComponent(decodeURIComponent(textContent));\n  } catch (e) {\n    try {\n      decodedContent = decodeURIComponent(textContent);\n    } catch (e2) {\n      // Keep original if decoding fails\n    }\n  }\n\n  // Handle URL-based format (tracking links from email)\n  const urlPattern = /himalayas\\.app\\/companies\\/([^\\/]+)\\/jobs\\/([^\\s\\/\\]\"&<>]+)/gi;\n  let urlMatch;\n\n  while ((urlMatch = urlPattern.exec(decodedContent)) !== null) {\n    const companySlug = urlMatch[1];\n    const titleSlug = urlMatch[2];\n\n    // Convert slugs to readable names\n    const company = companySlug\n      .split('-')\n      .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n      .join(' ');\n\n    const title = titleSlug\n      .replace(/-\\d+$/, '') // Remove trailing ID numbers like \"-9491544946\"\n      .split('-')\n      .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n      .join(' ');\n\n    if (title.length < 3 || company.length < 2) continue;\n\n    const key = `${title.toLowerCase()}-${company.toLowerCase()}`;\n    if (seenJobs.has(key)) continue;\n    seenJobs.add(key);\n\n    jobs.push({\n      title: title,\n      company: company,\n      location: 'Remote',\n      salary: 'Not specified',\n      source: 'Himalayas',\n      url: `https://himalayas.app/companies/${companySlug}/jobs/${titleSlug}`,\n      jobId: `himalayas-${Date.now()}-${jobs.length}`\n    });\n  }\n\n  // FALLBACK 1: Text-based pattern for \"Your top matches\" format\n  if (jobs.length === 0) {\n    const matchSection = textContent.match(/Your top matches for[^]*?(\\d{4})\\s*([\\s\\S]*?)(?:See your matches|Sponsored jobs|Top jobs from)/i);\n\n    if (matchSection) {\n      const jobText = matchSection[2].trim();\n\n      const jobPattern = /([A-Za-z][A-Za-z\\s&\\-,]+(?:Manager|Director|Head|Lead|Engineer|Representative|Specialist|Coordinator|Analyst|Advisor|Consultant|Success|Support|Operations)(?:\\s*\\([^)]+\\))?)\\s+([A-Z][A-Za-z0-9\\s&]+?)(?=\\s+[A-Z][a-z]+\\s+(?:Manager|Director|Head|Lead|Engineer|Success|Support)|$)/gi;\n\n      let match;\n      while ((match = jobPattern.exec(jobText)) !== null) {\n        let title = match[1].trim();\n        let company = match[2].trim();\n\n        company = company.replace(/\\s+(Customer|Client|Implementation|Technical|Product|Senior|Junior|Lead)\\s*$/i, '').trim();\n\n        if (title.length < 5 || company.length < 2) continue;\n\n        const key = `${title.toLowerCase()}-${company.toLowerCase()}`;\n        if (seenJobs.has(key)) continue;\n        seenJobs.add(key);\n\n        jobs.push({\n          title: title,\n          company: company,\n          location: 'Remote',\n          salary: 'Not specified',\n          source: 'Himalayas',\n          url: 'https://himalayas.app/jobs',\n          jobId: `himalayas-${Date.now()}-${jobs.length}`\n        });\n      }\n    }\n  }\n\n  // FALLBACK 2: Line-by-line parsing\n  if (jobs.length === 0) {\n    const lines = textContent.split(/\\n/).map(l => l.trim()).filter(l => l.length > 3);\n    const titleKeywords = ['manager', 'director', 'head', 'lead', 'engineer', 'support', 'success',\n                           'specialist', 'coordinator', 'analyst', 'consultant', 'onboarding', 'implementation'];\n\n    for (let i = 0; i < lines.length - 1; i++) {\n      const line = lines[i];\n      const nextLine = lines[i + 1];\n\n      if (titleKeywords.some(k => line.toLowerCase().includes(k))) {\n        if (/^[A-Z]/.test(nextLine) &&\n            nextLine.length < 50 &&\n            !titleKeywords.some(k => nextLine.toLowerCase().includes(k)) &&\n            !nextLine.toLowerCase().includes('your') &&\n            !nextLine.toLowerCase().includes('email') &&\n            !nextLine.toLowerCase().includes('unsubscribe')) {\n\n          const key = `${line.toLowerCase()}-${nextLine.toLowerCase()}`;\n          if (seenJobs.has(key)) continue;\n          seenJobs.add(key);\n\n          jobs.push({\n            title: line,\n            company: nextLine,\n            location: 'Remote',\n            salary: 'Not specified',\n            source: 'Himalayas',\n            url: 'https://himalayas.app/jobs',\n            jobId: `himalayas-${Date.now()}-${i}`\n          });\n          i++;\n        }\n      }\n    }\n  }\n}\n\nelse if (source === 'Wellfound') {\n  // Wellfound format: \"Title Company / Size | Location | exp | Type\"\n\n  // First extract job URLs for linking\n  const urlMatches = [...textContent.matchAll(/wellfound\\.com\\/jobs\\?job_listing_slug=(\\d+[^\\s>\"'\\]]*)/gi)];\n  const jobSlugs = urlMatches.map(m => m[1]);\n\n  // Pattern for Wellfound job listings\n  const jobPattern = /([A-Za-z][A-Za-z\\s&\\-,\\(\\)]+?(?:Manager|Director|Specialist|Associate|Coordinator|Analyst|Engineer|Representative|Support|Success)(?:[A-Za-z\\s&\\-,\\(\\)]*?))\\s+([A-Z][A-Za-z0-9\\s&\\.\\-']+?)\\s*\\/\\s*(\\d+[-‚Äì]\\d+|\\d+\\+?)\\s*Employees/gi;\n\n  let match;\n  let index = 0;\n  while ((match = jobPattern.exec(textContent)) !== null) {\n    const title = match[1].trim();\n    const company = match[2].trim();\n    const size = match[3];\n\n    // Extract location from text after the match\n    const afterMatch = textContent.substring(match.index + match[0].length, match.index + match[0].length + 100);\n    const locationMatch = afterMatch.match(/\\|\\s*([^|]+?)(?:\\s*\\||$)/);\n    const location = locationMatch ? locationMatch[1].trim() : 'Remote';\n\n    jobs.push({\n      title: title,\n      company: company,\n      location: location,\n      salary: 'Not specified',\n      source: 'Wellfound',\n      url: jobSlugs[index] ? `https://wellfound.com/jobs?job_listing_slug=${jobSlugs[index]}` : 'https://wellfound.com',\n      jobId: jobSlugs[index] ? `wellfound-${jobSlugs[index].split('-')[0]}` : `wellfound-${Date.now()}-${index}`,\n      _companySize: `${size} Employees`\n    });\n    index++;\n  }\n}\n\nelse if (source === 'Built In') {\n  // Built In format: [Company] [Title] [Location] $[Salary]\n  // Use salary as anchor and work backwards\n  \n  // First extract job URLs from HTML\n  const builtInUrls = [];\n  const searchContent = htmlContent || textContent;\n  // Match Built In job URLs - various formats\n  const urlPattern = /https?:\\/\\/(?:www\\.)?builtin\\.com\\/job\\/[^\\s\"'<>]+/gi;\n  let urlMatch;\n  while ((urlMatch = urlPattern.exec(searchContent)) !== null) {\n    builtInUrls.push(urlMatch[0].replace(/&amp;/g, '&'));\n  }\n  // Also check for tracking URLs that contain builtin job paths\n  const trackingPattern = /href=[\"']([^\"']*builtin[^\"']*job[^\"']*)[\"']/gi;\n  while ((urlMatch = trackingPattern.exec(searchContent)) !== null) {\n    const url = urlMatch[1].replace(/&amp;/g, '&');\n    if (!builtInUrls.includes(url)) builtInUrls.push(url);\n  }\n  \n  let jobIndex = 0;\n  \n  // Extract section between Job Preferences and Get More/footer\n  const sectionMatch = textContent.match(/(?:Senior Level|Expert Level|Entry Level|Mid Level)\\s+([\\s\\S]*?)(?:Get More|¬©|Built In,)/i);\n  if (sectionMatch) {\n    const jobSection = sectionMatch[1].trim();\n    \n    // Find all salary patterns to split jobs\n    const salaryPattern = /\\$[\\d,]+(?:\\s*-\\s*\\$?[\\d,]+)?/g;\n    const salaries = [];\n    let salaryMatch;\n    while ((salaryMatch = salaryPattern.exec(jobSection)) !== null) {\n      salaries.push({ text: salaryMatch[0], index: salaryMatch.index });\n    }\n    \n    // Process each job (text before each salary)\n    for (let i = 0; i < salaries.length; i++) {\n      const startIdx = i === 0 ? 0 : salaries[i-1].index + salaries[i-1].text.length;\n      const endIdx = salaries[i].index;\n      const jobText = jobSection.substring(startIdx, endIdx).trim();\n      const salary = salaries[i].text;\n      \n      if (jobText.length < 10) continue;\n      \n      // Location is typically at the end: \"Remote\", \"Remote Multiple Locations\", or city\n      const locationPattern = /((?:Remote(?:\\s+[A-Za-z]+)*|[A-Z][a-z]+(?:,\\s*[A-Z]{2})?))\\s*$/;\n      const locMatch = jobText.match(locationPattern);\n      const location = locMatch ? locMatch[1].trim() : 'Not specified';\n      const textWithoutLocation = locMatch ? jobText.substring(0, locMatch.index).trim() : jobText;\n      \n      // Title starts with keywords like Sr, Associate, Manager, Director, Engineer, etc.\n      const titlePattern = /((?:Sr\\.?|Jr\\.?|Senior|Junior|Lead|Staff|Principal|Associate|Manager|Director|VP|Head|Chief|Engineer|Specialist|Coordinator|Representative|Analyst|Consultant|Support|Customer|Digital|Technical)[\\s\\S]*?)$/i;\n      const titleMatch = textWithoutLocation.match(titlePattern);\n      \n      let title = '';\n      let company = '';\n      \n      if (titleMatch) {\n        title = titleMatch[1].trim();\n        company = textWithoutLocation.substring(0, titleMatch.index).trim();\n      } else {\n        // Fallback: assume first 1-3 words are company, rest is title\n        const words = textWithoutLocation.split(/\\s+/);\n        if (words.length >= 3) {\n          company = words.slice(0, 2).join(' ');\n          title = words.slice(2).join(' ');\n        }\n      }\n      \n      if (title && company && title.length > 3) {\n        jobs.push({\n          title: title,\n          company: company,\n          location: location,\n          salary: salary,\n          source: 'Built In',\n          url: builtInUrls[jobIndex] || 'https://builtin.com/jobs',\n          jobId: `builtin-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n        });\n        jobIndex++;\n      }\n    }\n  }\n  \n  // Fallback: Try \"at\" pattern\n  if (jobs.length === 0) {\n    const atPattern = /([A-Za-z\\s,\\/&]+(?:Support|Success|Director|Manager|Head|VP|Lead|Engineer|Representative|Specialist)[A-Za-z\\s,\\/&]*)\\s+at\\s+([A-Za-z0-9\\s&.,'\\\\-]+?)(?:\\s+in\\s+([A-Za-z\\s,]+?))?(?:\\n|$)/gi;\n    let match;\n    let fallbackIdx = 0;\n    while ((match = atPattern.exec(textContent)) !== null) {\n      jobs.push({\n        title: match[1].trim(),\n        company: match[2].trim(),\n        location: match[3] ? match[3].trim() : 'Not specified',\n        salary: 'Not specified',\n        source: 'Built In',\n        url: builtInUrls[fallbackIdx] || 'https://builtin.com/jobs',\n        jobId: `builtin-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n      });\n      fallbackIdx++;\n    }\n  }\n}\n\nelse if (source === 'Remotive') {\n  // Remotive emails use Postmark tracking URLs containing real job URLs\n  // Format: track.pstmrk.it/3s/{URL-ENCODED-JOB-URL}/eHy2/{tracking}\n  // Structure: <li>...<a href=\"tracking-url\"><span>Title</span> at <span>Company</span></a> &#x1F4CD; Location</li>\n\n  let searchContent = htmlContent || textContent;\n\n  // Decode quoted-printable encoding (=XX hex codes, =\\n soft line breaks)\n  searchContent = searchContent\n    .replace(/=\\r?\\n/g, '')\n    .replace(/=([0-9A-Fa-f]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));\n\n  // Extract each <li> block which contains one job\n  const liPattern = /<li[^>]*>([\\s\\S]*?)<\\/li>/gi;\n  let liMatch;\n\n  while ((liMatch = liPattern.exec(searchContent)) !== null) {\n    const liContent = liMatch[1];\n\n    // Extract tracking URL from this <li>\n    const urlMatch = liContent.match(/href=[\"']https?:\\/\\/track\\.pstmrk\\.it\\/3s\\/([^\\/]+(?:%2F[^\\/]+)*)\\/eHy2/i);\n    if (!urlMatch) continue;\n\n    const encodedUrl = urlMatch[1];\n\n    // Decode the job URL\n    let jobUrl;\n    try {\n      jobUrl = 'https://' + decodeURIComponent(encodedUrl);\n    } catch (e) {\n      jobUrl = 'https://' + encodedUrl.replace(/%2F/gi, '/').replace(/%3A/gi, ':');\n    }\n\n    // Skip non-job URLs\n    if (jobUrl.includes('remotive.com') && !jobUrl.includes('remote-jobs/')) continue;\n    if (jobUrl.includes('linkedin.com/company')) continue;\n    if (jobUrl.includes('twitter.com')) continue;\n    if (jobUrl.includes('unsubscribe')) continue;\n\n    // Extract title: <span ...>Title</span>\n    const titleMatch = liContent.match(/<span[^>]*font-weight:\\s*bold[^>]*>([^<]+)<\\/span>/i);\n    const title = titleMatch ? titleMatch[1].trim() : '';\n\n    // Extract company: at <span ...>Company</span>\n    const companyMatch = liContent.match(/at\\s*<span[^>]*>([^<]+)<\\/span>/i);\n    const company = companyMatch ? companyMatch[1].trim() : '';\n\n    // Extract location: &#x1F4CD; Location or üìç Location\n    const locationMatch = liContent.match(/(?:&#x1F4CD;|\\u{1F4CD})\\s*([A-Za-z\\s,]+)/iu);\n    const location = locationMatch ? locationMatch[1].trim() : 'Remote';\n\n    if (title && company) {\n      jobs.push({\n        title: title,\n        company: company,\n        location: location,\n        salary: 'Not specified',\n        source: 'Remotive',\n        url: jobUrl,\n        jobId: `remotive-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n      });\n    }\n  }\n\n  // Fallback: If no <li> matches, try text-based pattern\n  if (jobs.length === 0) {\n    const textPattern = /([A-Za-z][A-Za-z\\s,\\/&\\-]+?(?:Manager|Director|Head|VP|Lead|Engineer|Specialist|Coordinator|Analyst|Representative|Support|Success)[A-Za-z\\s,\\/&]*)\\s+at\\s+([A-Za-z0-9][A-Za-z0-9\\s&.,'\\\\-]+?)(?:\\s*\\u{1F4CD}\\s*([A-Za-z\\s,]+))?(?:\\s|$|Looking)/giu;\n\n    let match;\n    while ((match = textPattern.exec(textContent)) !== null) {\n      jobs.push({\n        title: match[1].trim(),\n        company: match[2].trim(),\n        location: match[3] ? match[3].trim() : 'Remote',\n        salary: 'Not specified',\n        source: 'Remotive',\n        url: 'https://remotive.com/remote-jobs',\n        jobId: `remotive-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n      });\n    }\n  }\n}\n\nelse if (source === 'Indeed') {\n  // Extract Indeed job URLs first\n  const indeedUrls = [];\n  const searchContent = htmlContent || textContent;\n\n  // Pattern for Indeed job URLs (various formats)\n  const indeedUrlPattern = /https?:\\/\\/(?:[a-z]+\\.)?indeed\\.com\\/(?:viewjob\\?|rc\\/clk\\?|jobs\\?|job\\/)[^\\s\"'<>]+/gi;\n  let urlMatch;\n  while ((urlMatch = indeedUrlPattern.exec(searchContent)) !== null) {\n    indeedUrls.push(urlMatch[0].replace(/&amp;/g, '&'));\n  }\n\n  // Also check for shortened/tracking URLs\n  const trackingPattern = /to\\.indeed\\.com\\/[a-zA-Z0-9]+/gi;\n  while ((urlMatch = trackingPattern.exec(searchContent)) !== null) {\n    indeedUrls.push(`https://${urlMatch[0]}`);\n  }\n\n  const jobPattern = /([A-Za-z\\s,\\/&]+(?:Support|Success|Director|Manager|Head|VP|Lead|Engineer|Representative|Specialist)[A-Za-z\\s,\\/&]*)\\s+at\\s+([A-Za-z0-9\\s&.,'\\\\-]+?)(?:\\s*[-‚Äì]\\s*|\\s*\\n|\\s*$)/gi;\n\n  let match;\n  let jobIndex = 0;\n  while ((match = jobPattern.exec(textContent)) !== null) {\n    const salaryMatch = textContent.substring(match.index, match.index + 200).match(/\\$[\\d,]+(?:\\s*[-‚Äì]\\s*\\$[\\d,]+)?(?:\\s*(?:\\/|per|a)\\s*(?:year|yr|hour|hr|month))?/i);\n\n    jobs.push({\n      title: match[1].trim(),\n      company: match[2].trim(),\n      location: 'Not specified',\n      salary: salaryMatch ? salaryMatch[0].trim() : 'Not specified',\n      source: 'Indeed',\n      url: indeedUrls[jobIndex] || 'https://indeed.com',\n      jobId: `indeed-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n    });\n    jobIndex++;\n  }\n}\n\nelse if (source === 'Welcome to the Jungle') {\n  // Welcome to the Jungle uses SendGrid tracking URLs wrapping each job card\n  // Structure: <a href=\"sendgrid-url\">...<strong>Company</strong>...<strong>Title</strong>...Salary:...Location...</a>\n  \n  let searchContent = htmlContent || textContent;\n  \n  // Decode quoted-printable encoding\n  searchContent = searchContent\n    .replace(/=\\r?\\n/g, '')\n    .replace(/=3D/g, '=')\n    .replace(/=([0-9A-Fa-f]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));\n  \n  // Extract all SendGrid tracking URLs and their associated content blocks\n  // Each job card is wrapped in an <a> tag with a sendgrid URL\n  const jobBlocks = [];\n  const blockPattern = /<a[^>]*href=[\"']?(https:\\/\\/[^\"'\\s]*(?:sendgrid\\.net|ct\\.sendgrid\\.net)\\/ls\\/click[^\"'\\s]*)[\"']?[^>]*>[\\s\\S]*?<\\/a>/gi;\n  \n  let blockMatch;\n  while ((blockMatch = blockPattern.exec(searchContent)) !== null) {\n    const url = blockMatch[1];\n    const content = blockMatch[0];\n    \n    // Skip non-job blocks (logos, footers, etc.)\n    if (content.includes('Jungle logo') || content.includes('unsubscribe') || content.includes('manage your')) continue;\n    if (!content.includes('Salary:')) continue;\n    \n    jobBlocks.push({ url, content });\n  }\n  \n  const seenJobs = new Set();\n  \n  for (const block of jobBlocks) {\n    // Extract company: first <strong> tag with actual company name\n    const strongMatches = [...block.content.matchAll(/<strong>([^<]+)<\\/strong>/gi)];\n    let company = '';\n    let title = '';\n    \n    for (const sm of strongMatches) {\n      const text = sm[1].trim();\n      if (!text || text.length < 2) continue;\n      if (text.toLowerCase().includes('jungle')) continue;\n      \n      if (!company) {\n        company = text;\n      } else if (!title) {\n        title = text;\n        break;\n      }\n    }\n    \n    // Extract salary\n    const salaryMatch = block.content.match(/Salary:\\s*(\\$[\\d,]+(?:\\s*[-‚Äì]\\s*\\$?[\\d,]+)?K?)/i);\n    const salary = salaryMatch ? salaryMatch[1].trim() : 'Not specified';\n    \n    // Extract location (usually after salary, contains Remote/Hybrid or city)\n    const locationMatch = block.content.match(/(?:Remote|Hybrid|On-?site)[^<]*(?:\\([^)]+\\))?/i);\n    const location = locationMatch ? locationMatch[0].trim() : 'Not specified';\n    \n    if (title && company) {\n      const key = `${title.toLowerCase()}-${company.toLowerCase()}`;\n      if (seenJobs.has(key)) continue;\n      seenJobs.add(key);\n      \n      jobs.push({\n        title: title,\n        company: company,\n        location: location,\n        salary: salary,\n        source: 'Welcome to the Jungle',\n        url: block.url,\n        jobId: `wttj-${Date.now()}-${jobs.length}`\n      });\n    }\n  }\n  \n  // Fallback to original salary-based parsing if HTML parsing found nothing\n  if (jobs.length === 0) {\n    const salaryPattern = /Salary:\\s*\\$[\\d,]+(?:\\s*[-‚Äì]\\s*\\$?[\\d,]+)?K?/gi;\n    const salaryMatches = [...textContent.matchAll(salaryPattern)];\n    const titleKeywords = ['director', 'manager', 'head', 'lead', 'vp', 'vice president', 'chief', 'support', 'success', 'customer', 'experience', 'representative', 'specialist', 'engineer'];\n\n    for (let i = 0; i < salaryMatches.length; i++) {\n      const salaryMatch = salaryMatches[i];\n      const salaryText = salaryMatch[0];\n      const salaryIndex = salaryMatch.index;\n\n      const prevIndex = i > 0 ? salaryMatches[i-1].index + salaryMatches[i-1][0].length : 0;\n      const textBefore = textContent.substring(prevIndex, salaryIndex);\n\n      const lines = textBefore.split(/\\n|\\r|(?:\\s{3,})/).map(l => l.trim()).filter(l => l.length > 2);\n\n      let fallbackTitle = '';\n      let fallbackCompany = '';\n\n      for (let j = lines.length - 1; j >= 0; j--) {\n        const line = lines[j];\n        const lineLower = line.toLowerCase();\n\n        if (line.length > 80) continue;\n        if (lineLower.includes('click here') || lineLower.includes('unsubscribe')) continue;\n\n        if (!fallbackTitle && titleKeywords.some(k => lineLower.includes(k))) {\n          fallbackTitle = line;\n        } else if (fallbackTitle && !fallbackCompany && line.length < 40) {\n          fallbackCompany = line;\n          break;\n        }\n      }\n\n      if (fallbackTitle && fallbackCompany) {\n        jobs.push({\n          title: fallbackTitle,\n          company: fallbackCompany,\n          location: 'Not specified',\n          salary: salaryText.replace('Salary:', '').trim(),\n          source: 'Welcome to the Jungle',\n          url: 'https://www.welcometothejungle.com',\n          jobId: `wttj-${Date.now()}-${i}`\n        });\n      }\n    }\n  }\n}\n\nelse if (source === 'Google Careers') {\n  // Google Careers format: HTML email with job links in <u> tags\n  // URL: https://www.google.com/about/careers/applications/jobs/results/{id}-{slug}\n  // Title in <u> tags, Location after \"Google ‚Äì \"\n  \n  let searchContent = htmlContent || textContent;\n  // Decode quoted-printable encoding\n  searchContent = searchContent\n    .replace(/=\\r?\\n/g, '')\n    .replace(/=3D/g, '=')\n    .replace(/=([0-9A-Fa-f]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));\n  \n  // Pattern to find job listings: URL followed by title in <u> tags\n  const jobPattern = /href=([\"']?)https:\\/\\/www\\.google\\.com\\/about\\/careers\\/applications\\/jobs\\/results\\/(\\d+)-([^?\\s\"']+)[^>]*>[\\s\\S]*?<u>([^<]+)<\\/u>[\\s\\S]*?Google[\\s&;nbsp;]*[‚Äì-][\\s&;nbsp;]*([^<]+?)(?:<br|<\\/span)/gi;\n  \n  let match;\n  const seenIds = new Set();\n  \n  while ((match = jobPattern.exec(searchContent)) !== null) {\n    const jobId = match[2];\n    if (seenIds.has(jobId)) continue;\n    seenIds.add(jobId);\n    \n    const slug = match[3];\n    const title = match[4].trim();\n    let location = match[5].trim()\n      .replace(/&nbsp;/g, ' ')\n      .replace(/&ndash;/g, '-')\n      .replace(/<[^>]+>/g, '')\n      .trim();\n    \n    // Clean up location\n    if (location.toLowerCase().includes('yesterday') || location.toLowerCase().includes('days ago')) {\n      location = location.replace(/yesterday|\\d+ days? ago/gi, '').trim();\n    }\n    if (!location || location.length < 2) location = 'Multiple Sites';\n    \n    const url = `https://www.google.com/about/careers/applications/jobs/results/${jobId}-${slug}`;\n    \n    if (title) {\n      jobs.push({\n        title: title,\n        company: 'Google',\n        location: location,\n        salary: 'Not specified',\n        source: 'Google Careers',\n        url: url,\n        jobId: `google-${jobId}`\n      });\n    }\n  }\n  \n  // Fallback: simpler pattern\n  if (jobs.length === 0) {\n    const simplePattern = /google\\.com\\/about\\/careers\\/applications\\/jobs\\/results\\/(\\d+)-([^?\\s\"'&]+)[^>]*>.*?<u>([^<]+)<\\/u>/gi;\n    while ((match = simplePattern.exec(searchContent)) !== null) {\n      const jobId = match[1];\n      if (seenIds.has(jobId)) continue;\n      seenIds.add(jobId);\n      \n      const slug = match[2];\n      const title = match[3].trim();\n      \n      jobs.push({\n        title: title,\n        company: 'Google',\n        location: 'Multiple Sites',\n        salary: 'Not specified',\n        source: 'Google Careers',\n        url: `https://www.google.com/about/careers/applications/jobs/results/${jobId}-${slug}`,\n        jobId: `google-${jobId}`\n      });\n    }\n  }\n}\n\nelse if (source === 'Jobright') {\n  // Jobright.ai format - supports multiple email formats:\n  // Format 1 (old): HTML with id=\"job-section\", id=\"job-company-name\", id=\"job-title\", id=\"job-tag\"\n  // Format 2 (new - Jan 2026): Job cards in tables with border-radius: 16px, inline styles\n  //   - Title in <div style=\"font-size: 16px; font-weight: 640...\">\n  //   - Company in <div style=\"font-size: 13px; font-weight: 500...\">\n  //   - Salary/Location in <span style=\"...background: #f2f4f5...\">\n  //   - URL in <a href=\"https://jobright.ai/jobs/info/...\">\n  \n  let searchContent = htmlContent || textContent;\n  // Decode quoted-printable encoding\n  searchContent = searchContent\n    .replace(/=\\r?\\n/g, '')\n    .replace(/=3D/g, '=')\n    .replace(/=([0-9A-Fa-f]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));\n  \n  // Helper to determine if a tag is a salary (contains $ or K/yr)\n  const isSalaryTag = (tag) => /\\$\\d|\\d+K\\/yr/i.test(tag);\n  \n  // Helper to determine if a tag should be ignored (not salary or location)\n  const isIgnoredTag = (tag) => /referral|applicant|posted|ago|alumni|early applicant/i.test(tag);\n  \n  const seenUrls = new Set();\n  \n  // Try Format 2 first (new style with inline styles, Jan 2026)\n  // Split by job card tables (border-radius: 16px)\n  const tablePattern = /<table[^>]*border-radius:\\s*16px[^>]*>[\\s\\S]*?<\\/table>/gi;\n  const jobTables = searchContent.match(tablePattern) || [];\n  \n  for (const table of jobTables) {\n    // Must have an APPLY NOW link to be a job card\n    if (!table.includes('APPLY NOW') && !table.includes('jobright.ai/jobs/info')) continue;\n    \n    // Extract URL from APPLY NOW link\n    const urlMatch = table.match(/href=[\"\\'](https:\\/\\/jobright\\.ai\\/jobs\\/info\\/[a-f0-9]+)/i);\n    if (!urlMatch) continue;\n    const url = urlMatch[1].trim();\n    if (seenUrls.has(url)) continue;\n    seenUrls.add(url);\n    \n    // Extract title: <div style=\"font-size: 16px; font-weight: 640...\">Title</div>\n    const titleMatch = table.match(/font-size:\\s*16px;\\s*font-weight:\\s*640[^>]*>\\s*([^<]+)/i);\n    const title = titleMatch ? titleMatch[1].trim() : '';\n    \n    // Extract company: <div style=\"font-size: 13px; font-weight: 500...\">Company</div>\n    const companyMatch = table.match(/font-size:\\s*13px;\\s*font-weight:\\s*500[^>]*>\\s*([^<]+)/i);\n    const company = companyMatch ? companyMatch[1].trim() : '';\n    \n    // Extract salary/location from spans with background: #f2f4f5\n    const tagPattern = /background:\\s*#f2f4f5[^>]*>\\s*([^<]+)/gi;\n    const tags = [];\n    let tagMatch;\n    while ((tagMatch = tagPattern.exec(table)) !== null) {\n      tags.push(tagMatch[1].trim());\n    }\n    \n    let salary = 'Not specified';\n    let location = 'Not specified';\n    \n    for (const tag of tags) {\n      if (isSalaryTag(tag)) {\n        salary = tag;\n      } else if (tag.length > 0 && !isIgnoredTag(tag)) {\n        location = tag;\n      }\n    }\n    \n    if (title && company) {\n      jobs.push({\n        title: title,\n        company: company,\n        location: location,\n        salary: salary,\n        source: 'Jobright',\n        url: url,\n        jobId: `jobright-${url.split('/').pop()}`\n      });\n    }\n  }\n  \n  // Try Format 1 (old style with IDs) if Format 2 found nothing\n  if (jobs.length === 0) {\n    const sections = searchContent.split(/(?=<a[^>]*href=\"https:\\/\\/jobright\\.ai\\/jobs\\/info\\/[^\"]+[^>]*>\\s*<table[^>]*id=\"job-section\")/gi);\n    \n    for (const section of sections) {\n      if (!section.includes('id=\"job-section\"')) continue;\n      \n      const urlMatch = section.match(/href=\"(https:\\/\\/jobright\\.ai\\/jobs\\/info\\/[^\"?]+)/);\n      if (!urlMatch) continue;\n      const url = urlMatch[1].trim();\n      if (seenUrls.has(url)) continue;\n      seenUrls.add(url);\n      \n      const companyMatch = section.match(/id=\"job-company-name\"[^>]*>([^<]+)</);\n      const company = companyMatch ? companyMatch[1].trim() : '';\n      \n      const titleMatch = section.match(/id=\"job-title\"[^>]*>[\\s\\S]*?>([^<]+)<\\/a>/);\n      const title = titleMatch ? titleMatch[1].trim() : '';\n      \n      const tagMatches = [...section.matchAll(/id=\"job-tag\"[^>]*>([^<]+)</gi)];\n      const tags = tagMatches.map(m => m[1].trim());\n      \n      let salary = 'Not specified';\n      let location = 'Not specified';\n      \n      for (const tag of tags) {\n        if (isSalaryTag(tag)) {\n          salary = tag;\n        } else if (tag.length > 0 && !isIgnoredTag(tag)) {\n          location = tag;\n        }\n      }\n      \n      if (title && company) {\n        jobs.push({\n          title: title,\n          company: company,\n          location: location,\n          salary: salary,\n          source: 'Jobright',\n          url: url,\n          jobId: `jobright-${url.split('/').pop()}`\n        });\n      }\n    }\n  }\n  \n  // Fallback: Extract components separately and match by position (old format)\n  if (jobs.length === 0 && searchContent.includes('id=\"job-company-name\"')) {\n    const urlPattern = /https:\\/\\/jobright\\.ai\\/jobs\\/info\\/([a-f0-9]+)/gi;\n    const urls = [];\n    let urlMatch;\n    while ((urlMatch = urlPattern.exec(searchContent)) !== null) {\n      const url = `https://jobright.ai/jobs/info/${urlMatch[1]}`;\n      if (!urls.includes(url)) urls.push(url);\n    }\n    \n    const companyPattern = /id=\"job-company-name\"[^>]*>([^<]+)</gi;\n    const companies = [];\n    while ((match = companyPattern.exec(searchContent)) !== null) {\n      companies.push(match[1].trim());\n    }\n    \n    const titlePattern = /id=\"job-title\"[^>]*>[\\s\\S]*?>([^<]+)<\\/a>/gi;\n    const titles = [];\n    while ((match = titlePattern.exec(searchContent)) !== null) {\n      titles.push(match[1].trim());\n    }\n    \n    const tagPattern = /id=\"job-tag\"[^>]*>([^<]+)</gi;\n    const allTags = [];\n    while ((match = tagPattern.exec(searchContent)) !== null) {\n      allTags.push(match[1].trim());\n    }\n    \n    let tagIndex = 0;\n    for (let i = 0; i < Math.min(urls.length, titles.length, companies.length); i++) {\n      let salary = 'Not specified';\n      let location = 'Not specified';\n      \n      while (tagIndex < allTags.length) {\n        const tag = allTags[tagIndex];\n        tagIndex++;\n        \n        if (isSalaryTag(tag)) {\n          salary = tag;\n        } else if (!isIgnoredTag(tag)) {\n          location = tag;\n          break;\n        }\n      }\n      \n      jobs.push({\n        title: titles[i],\n        company: companies[i],\n        location: location,\n        salary: salary,\n        source: 'Jobright',\n        url: urls[i],\n        jobId: `jobright-${urls[i].split('/').pop()}`\n      });\n    }\n  }\n}\n\nelse {\n  // Generic parser for unknown sources\n  const atPattern = /([A-Za-z\\s,\\/&]+(?:Support|Success|Director|Manager|Head|VP|Lead|Engineer)[A-Za-z\\s,\\/&]*)\\s+at\\s+([A-Za-z0-9\\s&.,'\\\\-]+)/gi;\n  let match;\n  while ((match = atPattern.exec(textContent)) !== null) {\n    jobs.push({\n      title: match[1].trim(),\n      company: match[2].trim(),\n      location: 'Not specified',\n      salary: 'Not specified',\n      source: source,\n      url: '',\n      jobId: `other-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n    });\n  }\n}\n\n} catch (e) {\n  // Capture parser error but continue processing\n  parserError = { source: source, error: e.message };\n}\n\n// Deduplicate jobs within this email by title+company\n  const seen = new Set();\n  const uniqueJobs = jobs.filter(job => {\n    const key = `${job.title.toLowerCase()}-${job.company.toLowerCase()}`;\n    if (seen.has(key)) return false;\n    seen.add(key);\n    return true;\n  });\n\n  // Add jobs from this email to the master list\n  const emailId = email.id || '';\n  if (uniqueJobs.length === 0) {\n    allJobs.push({ _noJobs: true, _source: source, _rawText: (textContent || '').substring(0, 500), _emailId: emailId, _parserError: parserError });\n  } else {\n    for (const job of uniqueJobs) {\n      allJobs.push({\n        title: job.title,\n        company: job.company,\n        location: job.location,\n        salary: job.salary,\n        source: job.source,\n        url: job.url,\n        jobId: job.jobId,\n        _dateFound: new Date().toISOString().split('T')[0],\n        _emailId: emailId\n      });\n    }\n  }\n} // End of email loop\n\n// Return all collected jobs\nif (allJobs.length === 0) {\n  return [{ json: { _noJobs: true, _source: 'None' } }];\n}\n\nreturn allJobs.map(job => ({ json: job }));"
      },
      "id": "f6fb4efd-ecc4-4d31-b1e8-ba8b3f252699",
      "name": "Parse Jobs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1632,
        -416
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json._noJobs }}",
              "operation": "notEqual",
              "value2": true
            }
          ]
        }
      },
      "id": "a0386dbd-bbe6-4799-816e-1b6e3984a028",
      "name": "Has Jobs",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -1408,
        -416
      ],
      "executeOnce": false
    },
    {
      "parameters": {
        "authentication": "airtableTokenApi",
        "operation": "append",
        "application": "appFEzXvPWvRtXgRY",
        "table": "tbl6ZV2rHjWz56pP3",
        "addAllFields": false,
        "fields": [
          "Job Title",
          "Company",
          "Location",
          "Source",
          "Job URL",
          "Job ID",
          "Salary Info",
          "Date Found",
          "Review Status",
          "Tide-Pool Score",
          "Tide-Pool Rationale",
          "Company Stage",
          "Industry"
        ],
        "options": {}
      },
      "id": "3d21cc2b-da2f-4e29-874e-0da22e35de60",
      "name": "Add to Airtable",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 1,
      "position": [
        -512,
        -224
      ],
      "credentials": {
        "airtableTokenApi": {
          "id": "sempBDy7tuv1mA6y",
          "name": "Airtable Personal Access Token account"
        }
      }
    },
    {
      "parameters": {},
      "id": "9b23e798-57a0-49cd-8e38-98ca836c7fcd",
      "name": "No Jobs Found",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -1184,
        -464
      ]
    },
    {
      "parameters": {
        "jsCode": "// Transform field names to match Airtable exactly\n// Filter to only customer support/success leadership roles\n\nconst items = $input.all().filter(item => !item.json._empty);\n\nif (items.length === 0) {\n  return [{ json: { _empty: true } }];\n}\n\n// Role filter: must contain support/success keywords AND leadership keywords\nconst supportKeywords = ['support', 'success', 'customer', 'client', 'cx', 'experience'];\nconst leadershipKeywords = ['manager', 'director', 'vp', 'vice president', 'head', 'lead', 'chief', 'supervisor', 'team lead'];\n\nconst filteredItems = items.filter(item => {\n  const title = (item.json.title || '').toLowerCase();\n  \n  // Check if title contains any support/success keyword\n  const hasSupport = supportKeywords.some(kw => title.includes(kw));\n  \n  // Check if title contains any leadership keyword\n  const hasLeadership = leadershipKeywords.some(kw => title.includes(kw));\n  \n  return hasSupport && hasLeadership;\n});\n\nif (filteredItems.length === 0) {\n  return [{ json: { _empty: true } }];\n}\n\nreturn filteredItems.map(item => ({\n  json: {\n    \"Job Title\": item.json.title,\n    \"Company\": item.json.company,\n    \"Location\": item.json.location,\n    \"Source\": item.json.source,\n    \"Job URL\": item.json.url,\n    \"Job ID\": item.json.jobId,\n    \"Salary Info\": item.json.salary,\n    \"Date Found\": item.json._dateFound,\n    \"Review Status\": \"New\",\n    \"_emailId\": item.json._emailId\n  }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -736,
        -224
      ],
      "id": "2bfe51ad-db26-409f-a152-df4184505056",
      "name": "Map Fields for Airtable"
    },
    {
      "parameters": {
        "mode": "append"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -1184,
        -224
      ],
      "id": "merge-dedup-inputs",
      "name": "Merge Inputs"
    },
    {
      "parameters": {
        "operation": "getAll",
        "returnAll": true,
        "simple": false,
        "filters": {
          "q": "is:unread in:inbox from:(jobs-listings@linkedin.com OR jobalerts-noreply@linkedin.com OR jobs-noreply@linkedin.com OR builtin.com OR wellfound.com OR himalayas.app OR remotive.com OR welcometothejungle.com OR jobright.ai OR careers-noreply@google.com) newer_than:21d"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [
        -2080,
        -416
      ],
      "id": "12b46d30-8170-49aa-adf7-9fdcba3ab327",
      "name": "Get many messages",
      "webhookId": "46595c63-cee2-41ff-834e-8114edf3d651",
      "credentials": {
        "gmailOAuth2": {
          "id": "vUMmpPTSbHvfz72M",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 1
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.3,
      "position": [
        -2304,
        -416
      ],
      "id": "c858cdb6-ed8a-4834-a20f-ee17efb13799",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "operation": "addLabels",
        "messageId": "={{ $('Filter Empty').item.json._emailId }}",
        "labelIds": [
          "Label_3146569228785124450"
        ]
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [
        -288,
        -224
      ],
      "id": "040a7872-484b-41be-a763-034418f062f6",
      "name": "Add label to message",
      "webhookId": "a29818cc-9d22-40cb-ad01-47c3f481b26c",
      "credentials": {
        "gmailOAuth2": {
          "id": "vUMmpPTSbHvfz72M",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "value": "appFEzXvPWvRtXgRY",
          "mode": "list",
          "cachedResultName": "Job search",
          "cachedResultUrl": "https://airtable.com/appFEzXvPWvRtXgRY"
        },
        "table": {
          "__rl": true,
          "value": "tbl6ZV2rHjWz56pP3",
          "mode": "list",
          "cachedResultName": "Job Listings",
          "cachedResultUrl": "https://airtable.com/appFEzXvPWvRtXgRY/tbl6ZV2rHjWz56pP3"
        },
        "options": {
          "filterByFormula": "IS_AFTER({Date Found}, DATEADD(TODAY(), -30, 'days'))"
        }
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        -1632,
        -176
      ],
      "id": "ebf4cca2-69c9-460c-bb37-7b12dd7a21bb",
      "name": "Search records",
      "credentials": {
        "airtableTokenApi": {
          "id": "sempBDy7tuv1mA6y",
          "name": "Airtable Personal Access Token account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Dedup Code v2 - More aggressive normalization\n\n// Normalize function: lowercase, collapse spaces, remove special chars\nconst normalize = (str) => {\n  if (!str) return '';\n  return str\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s]/g, '') // remove special chars\n    .replace(/\\s+/g, ' ')        // collapse multiple spaces\n    .trim();\n};\n\nconst allItems = $input.all();\n\n// Separate new jobs from existing Airtable records\nconst newJobs = allItems.filter(item => \n  item.json.title && item.json.source && !item.json.fields && !item.json[\"Job Title\"]\n);\n\nconst existingRecords = allItems.filter(item => \n  item.json.fields || item.json[\"Job Title\"] || (item.json[\"Job URL\"] && !item.json.source)\n);\n\n// Build sets of existing URLs and normalized title+company keys\nconst existingUrls = new Set();\nconst existingKeys = new Set();\n\nfor (const item of existingRecords) {\n  const fields = item.json.fields || item.json;\n  \n  // Add URL (normalized - remove trailing slashes, params)\n  let url = fields[\"Job URL\"] || \"\";\n  if (url) {\n    url = url.split('?')[0].replace(/\\/$/, ''); // remove query params and trailing slash\n    existingUrls.add(url);\n  }\n  \n  // Add normalized title+company key\n  const title = normalize(fields[\"Job Title\"] || \"\");\n  const company = normalize(fields[\"Company\"] || \"\");\n  if (title && company) {\n    existingKeys.add(title + \"|\" + company);\n  }\n}\n\n// Filter new jobs against existing\nconst results = [];\n\nfor (const job of newJobs) {\n  // Normalize URL\n  let url = job.json.url || \"\";\n  if (url) {\n    url = url.split('?')[0].replace(/\\/$/, '');\n  }\n  \n  // Normalize title and company\n  const title = normalize(job.json.title || \"\");\n  const company = normalize(job.json.company || \"\");\n  const key = title + \"|\" + company;\n  \n  // Skip if URL already exists (and URL is specific, not generic)\n  const isGenericUrl = url.endsWith('/jobs') || url.endsWith('/remote-jobs');\n  if (url && !isGenericUrl && existingUrls.has(url)) continue;\n  \n  // Skip if title+company combo exists\n  if (existingKeys.has(key)) continue;\n  \n  // Add to sets to prevent duplicates within this batch\n  if (url && !isGenericUrl) existingUrls.add(url);\n  existingKeys.add(key);\n  \n  results.push(job);\n}\n\nreturn results.length ? results : [{ json: { _empty: true } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -960,
        -224
      ],
      "id": "6f2b2eb2-c6b9-47d2-8c3a-b432aadb1bb4",
      "name": "Dedup Against Airtable"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json._empty }}",
              "operation": "notEqual",
              "value2": true
            }
          ]
        }
      },
      "id": "filter-empty",
      "name": "Filter Empty",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -512,
        -416
      ]
    },
    {
      "parameters": {
        "operation": "markAsRead",
        "messageId": "={{ $json.id }}"
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [
        -1968,
        -416
      ],
      "id": "mark-as-read-early",
      "name": "Mark as Read",
      "credentials": {
        "gmailOAuth2": {
          "id": "vUMmpPTSbHvfz72M",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://raw.githubusercontent.com/zelman/tidepool/refs/heads/main/tide-pool-agent-lens.md",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -512,
        -32
      ],
      "id": "fetch-profile",
      "name": "Fetch Profile"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build prompt for Claude API - store job data and profile for next node\nconst jobData = $('Map Fields for Airtable').item.json;\nconst profileContent = $('Fetch Profile').first().json.data || $('Fetch Profile').first().json;\n\n// Get API key from Airtable Config (env vars blocked on n8n Cloud)\nconst configData = $('Get Config').first().json;\nconst apiKey = configData.fields?.Value || configData.Value || '';\n\n// Skip empty items\nif (jobData._empty) {\n  return { json: { ...jobData, _skip: true } };\n}\n\nconst prompt = `Rate how well this job matches the candidate profile. Also identify the company's industry and funding stage.\n\nReturn ONLY a JSON object with these fields:\n- score: 0-100 fit score\n- rationale: 1-2 sentence explanation\n- industry: company's industry (e.g., \"Healthcare Tech\", \"FinTech\", \"E-commerce\", \"SaaS\", \"EdTech\", etc.)\n- companyStage: funding stage (e.g., \"Seed\", \"Series A\", \"Series B\", \"Series C+\", \"Public\", \"Private/Bootstrapped\", \"Unknown\")\n\nCANDIDATE PROFILE:\n${typeof profileContent === 'string' ? profileContent : JSON.stringify(profileContent)}\n\nJOB TO EVALUATE:\nTitle: ${jobData['Job Title']}\nCompany: ${jobData['Company']}\nLocation: ${jobData['Location']}\nSalary: ${jobData['Salary Info']}\nSource: ${jobData['Source']}\n\nRespond with JSON only: {\"score\": NUMBER, \"rationale\": \"TEXT\", \"industry\": \"TEXT\", \"companyStage\": \"TEXT\"}`;\n\nreturn {\n  json: {\n    ...jobData,\n    _prompt: prompt,\n    _apiKey: apiKey\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -288,
        -32
      ],
      "id": "build-prompt",
      "name": "Build Prompt"
    },
    {
      "parameters": {
        "amount": 2,
        "unit": "seconds"
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -176,
        -32
      ],
      "id": "wait-rate-limit",
      "name": "Wait (Rate Limit)",
      "webhookId": "rate-limit-wait"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $json._apiKey }}"
            },
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"claude-3-haiku-20240307\",\n  \"max_tokens\": 300,\n  \"messages\": [{\"role\": \"user\", \"content\": {{ JSON.stringify($json._prompt) }}}]\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -64,
        -32
      ],
      "id": "call-claude",
      "name": "Call Claude API",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Parse Claude response and add scores to job data\nconst input = $json;\nconst jobData = $('Build Prompt').item.json;\n\n// Skip if marked to skip\nif (jobData._skip) {\n  return { json: jobData };\n}\n\nlet fitScore = 0;\nlet fitRationale = 'Unable to rate';\nlet industry = '';\nlet companyStage = '';\n\ntry {\n  if (input.content && input.content[0] && input.content[0].text) {\n    const content = input.content[0].text;\n    const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      const parsed = JSON.parse(jsonMatch[0]);\n      fitScore = parsed.score || 0;\n      fitRationale = parsed.rationale || 'No rationale provided';\n      industry = parsed.industry || '';\n      companyStage = parsed.companyStage || '';\n    }\n  } else if (input.error) {\n    fitRationale = 'API Error: ' + (input.error.message || JSON.stringify(input.error));\n  }\n} catch (e) {\n  fitRationale = 'Error: ' + e.message;\n}\n\n// Remove internal fields before returning\nconst { _prompt, _skip, _apiKey, ...cleanJobData } = jobData;\n\nreturn {\n  json: {\n    ...cleanJobData,\n    'Tide-Pool Score': fitScore,\n    'Tide-Pool Rationale': fitRationale,\n    'Industry': industry,\n    'Company Stage': companyStage\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        160,
        -32
      ],
      "id": "parse-response",
      "name": "Parse Response"
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "value": "appFEzXvPWvRtXgRY",
          "mode": "list",
          "cachedResultName": "Job search",
          "cachedResultUrl": "https://airtable.com/appFEzXvPWvRtXgRY"
        },
        "table": {
          "__rl": true,
          "value": "tblofzQpzGEN8igVS",
          "mode": "id"
        },
        "filterByFormula": "{Key} = 'ANTHROPIC_API_KEY'",
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        -1632,
        -576
      ],
      "id": "get-config",
      "name": "Get Config",
      "credentials": {
        "airtableTokenApi": {
          "id": "sempBDy7tuv1mA6y",
          "name": "Airtable Personal Access Token account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Identify Source": {
      "main": [
        [
          {
            "node": "Parse Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Jobs": {
      "main": [
        [
          {
            "node": "Has Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Jobs": {
      "main": [
        [
          {
            "node": "Merge Inputs",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Jobs Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Fields for Airtable": {
      "main": [
        [
          {
            "node": "Fetch Profile",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Profile": {
      "main": [
        [
          {
            "node": "Build Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Prompt": {
      "main": [
        [
          {
            "node": "Wait (Rate Limit)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait (Rate Limit)": {
      "main": [
        [
          {
            "node": "Call Claude API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Claude API": {
      "main": [
        [
          {
            "node": "Parse Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Response": {
      "main": [
        [
          {
            "node": "Filter Empty",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get many messages": {
      "main": [
        [
          {
            "node": "Mark as Read",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark as Read": {
      "main": [
        [
          {
            "node": "Identify Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Get many messages",
            "type": "main",
            "index": 0
          },
          {
            "node": "Search records",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add to Airtable": {
      "main": [
        [
          {
            "node": "Add label to message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search records": {
      "main": [
        [
          {
            "node": "Merge Inputs",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Inputs": {
      "main": [
        [
          {
            "node": "Dedup Against Airtable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dedup Against Airtable": {
      "main": [
        [
          {
            "node": "Map Fields for Airtable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Empty": {
      "main": [
        [
          {
            "node": "Add to Airtable",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "timeSavedMode": "fixed",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": true
  },
  "versionId": "e70726e2-ef3f-416c-8180-f8ac61b7bace",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "a6a425099b9f9cd9abf3e131a46fe3b1ceb58f2f047bc24ddb7c77d018810088"
  },
  "id": "x54NNk1Mw7LNhX9o",
  "tags": []
}
