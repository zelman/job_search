{
  "name": "Job Alert Email Parser v3-28",
  "nodes": [
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Route based on email sender - reference original email data from Get many messages\nconst emailData = $('Get many messages').item.json;\nlet from = emailData.from || emailData.From || '';\n\n// Handle object format (Gmail returns {value: [{address, name}], text, html})\nif (from && typeof from === 'object') {\n  from = from.text || (from.value && from.value[0] && from.value[0].address) || '';\n}\n\n// If not found, check payload.headers (Gmail API format)\nif (!from && emailData.payload && emailData.payload.headers) {\n  const headers = emailData.payload.headers;\n  const fromHeader = headers.find(h => h.name.toLowerCase() === 'from');\n  if (fromHeader) from = fromHeader.value;\n}\n\nconst fromLower = (from || '').toLowerCase();\n\nlet source = 'Other';\nif (fromLower.includes('indeed')) source = 'Indeed';\nelse if (fromLower.includes('linkedin')) source = 'LinkedIn';\nelse if (fromLower.includes('wellfound')) source = 'Wellfound';\nelse if (fromLower.includes('builtin') || fromLower.includes('built-in') || fromLower.includes('built in')) source = 'Built In';\nelse if (fromLower.includes('remotive')) source = 'Remotive';\nelse if (fromLower.includes('himalayas')) source = 'Himalayas';\nelse if (fromLower.includes('welcometothejungle')) source = 'Welcome to the Jungle';\nelse if (fromLower.includes('jobright')) source = 'Jobright';\nelse if (fromLower.includes('careers-noreply@google.com') || fromLower.includes('google.com/about/careers')) source = 'Google Careers';\nelse if (fromLower.includes('bloomberry')) source = 'Bloomberry';\n\nreturn { json: { ...emailData, _source: source } };"
      },
      "id": "d27f26b3-6684-4e8a-ab73-ac1d5757f49c",
      "name": "Identify Source",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "jsCode": "// Parse Jobs - Multi-source parser v9 (Run Once for All Items mode)\n// Process all emails and collect all jobs into one output array\n\nconst allEmails = $input.all();\nconst allJobs = [];\n\n// Helper function to decode base64url (Gmail API format)\nconst decodeBase64Url = (data) => {\n  if (!data) return '';\n  if (/\\s{2,}/.test(data) && /[a-z]{4,}\\s+[a-z]{4,}/i.test(data)) return data;\n  const sample = data.substring(0, 100);\n  if (!/\\s/.test(sample) && /^[A-Za-z0-9_-]+=*$/.test(sample.replace(/\\s/g, ''))) {\n    try {\n      const cleaned = data.replace(/\\s/g, '');\n      const base64 = cleaned.replace(/-/g, '+').replace(/_/g, '/');\n      const decoded = Buffer.from(base64, 'base64').toString('utf-8');\n      if (/[a-z]{3,}/i.test(decoded) && !/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/.test(decoded)) return decoded;\n    } catch (e) {}\n  }\n  return data;\n};\n\n// Helper to strip HTML tags\nconst stripHtml = (html) => {\n  if (!html) return '';\n  return html\n    .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')\n    .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')\n    .replace(/<[^>]+>/g, ' ')\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&#39;/g, \"'\")\n    .replace(/&quot;/g, '\"')\n    .replace(/\\s+/g, ' ')\n    .trim();\n};\n\n// Helper to recursively find text content in MIME parts\nconst extractTextFromParts = (parts) => {\n  if (!parts || !Array.isArray(parts)) return '';\n\n  for (const part of parts) {\n    const mimeType = part.mimeType || '';\n\n    if (mimeType === 'text/plain' && part.body && part.body.data) {\n      return decodeBase64Url(part.body.data);\n    }\n\n    if (mimeType.startsWith('multipart/') && part.parts) {\n      const nested = extractTextFromParts(part.parts);\n      if (nested) return nested;\n    }\n  }\n\n  // Fallback to text/html\n  for (const part of parts) {\n    if (part.mimeType === 'text/html' && part.body && part.body.data) {\n      const html = decodeBase64Url(part.body.data);\n      return stripHtml(html);\n    }\n    if (part.parts) {\n      const nested = extractTextFromParts(part.parts);\n      if (nested) return nested;\n    }\n  }\n\n  return '';\n};\n\n// Helper to extract raw HTML from email (for URL extraction)\nconst extractHtmlFromParts = (parts) => {\n  if (!parts || !Array.isArray(parts)) return '';\n\n  for (const part of parts) {\n    if (part.mimeType === 'text/html' && part.body && part.body.data) {\n      return decodeBase64Url(part.body.data);\n    }\n    if (part.parts) {\n      const nested = extractHtmlFromParts(part.parts);\n      if (nested) return nested;\n    }\n  }\n  return '';\n};\n\n// Process each email\nfor (const emailItem of allEmails) {\n  const email = emailItem.json;\n  const source = email._source || 'Other';\n  \n  // Try multiple possible locations for email body content\n  let textContent = '';\n  let htmlContent = '';\n\n  // 1. Check common field names first (n8n Gmail node simplified output)\n  if (email.textPlain) textContent = email.textPlain;\n  if (email.textHtml) htmlContent = email.textHtml;\n  else if (email.html) htmlContent = email.html;\n  if (email.text) textContent = email.text;\n\n  // 2. Check Gmail-specific structure: payload\n  if (email.payload) {\n    const payload = email.payload;\n    if (payload.mimeType === 'text/html' && payload.body && payload.body.data) {\n      htmlContent = decodeBase64Url(payload.body.data);\n      if (!textContent) textContent = stripHtml(htmlContent);\n    }\n    else if (payload.parts && payload.parts.length > 0) {\n      if (!htmlContent) htmlContent = extractHtmlFromParts(payload.parts);\n      if (!textContent) textContent = extractTextFromParts(payload.parts);\n    }\n    else if (payload.body && payload.body.data) {\n      if (!textContent) textContent = decodeBase64Url(payload.body.data);\n    }\n  }\n\n  // 3. Fallback to snippet\n  if (!textContent && email.snippet) textContent = email.snippet;\n\n  // 4. Final fallback: convert HTML to text if still no text content\n  if (!textContent && htmlContent) textContent = stripHtml(htmlContent);\n\n  const jobs = [];\n  let parserError = null;\n\n// === SOURCE-SPECIFIC PARSERS ===\n\ntry {\n\nif (source === 'LinkedIn') {\n  const sections = textContent.split(/[-]{10,}/);\n\n  for (const section of sections) {\n    const urlMatch = section.match(/linkedin\\.com\\/(?:comm\\/)?jobs\\/view\\/(\\d+)/);\n    if (!urlMatch) continue;\n\n    const jobId = urlMatch[1];\n    const jobUrl = `https://www.linkedin.com/jobs/view/${jobId}`;\n\n    const textBefore = section.split(/View job/i)[0].trim();\n\n    const parts = textBefore\n      .replace(/https?:\\/\\/[^\\s]+/g, '')\n      .split(/\\n/)\n      .map(p => p.replace(/\\s+/g, ' ').trim())\n      .filter(p => p.length > 1);\n\n    const noise = ['high skills match', 'fast growing', 'actively hiring', 'connections', 'posted', 'applicants', 'promoted', 'apply with resume', 'this company is', 'school alum', 'connection', 'top job picks', 'your job alert', 'new jobs match your preferences', 'match your preferences'];\n    const cleanParts = parts.filter(p => !noise.some(n => p.toLowerCase().includes(n)));\n\n    if (cleanParts.length >= 2) {\n      jobs.push({\n        title: cleanParts[0],\n        company: cleanParts[1],\n        location: cleanParts[2] || 'United States',\n        salary: 'Not specified',\n        source: 'LinkedIn',\n        url: jobUrl,\n        jobId: `linkedin-${jobId}`\n      });\n    }\n  }\n}\n\nelse if (source === 'Himalayas') {\n  const seenJobs = new Set();\n\n  let decodedContent = textContent;\n  try {\n    decodedContent = decodeURIComponent(decodeURIComponent(textContent));\n  } catch (e) {\n    try {\n      decodedContent = decodeURIComponent(textContent);\n    } catch (e2) {}\n  }\n\n  const urlPattern = /himalayas\\.app\\/companies\\/([^\\/]+)\\/jobs\\/([^\\s\\/\\]\"&<>]+)/gi;\n  let urlMatch;\n\n  while ((urlMatch = urlPattern.exec(decodedContent)) !== null) {\n    const companySlug = urlMatch[1];\n    const titleSlug = urlMatch[2];\n\n    const company = companySlug\n      .split('-')\n      .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n      .join(' ');\n\n    const title = titleSlug\n      .replace(/-\\d+$/, '')\n      .split('-')\n      .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n      .join(' ');\n\n    if (title.length < 3 || company.length < 2) continue;\n\n    const key = `${title.toLowerCase()}-${company.toLowerCase()}`;\n    if (seenJobs.has(key)) continue;\n    seenJobs.add(key);\n\n    jobs.push({\n      title: title,\n      company: company,\n      location: 'Remote',\n      salary: 'Not specified',\n      source: 'Himalayas',\n      url: `https://himalayas.app/companies/${companySlug}/jobs/${titleSlug}`,\n      jobId: `himalayas-${Date.now()}-${jobs.length}`\n    });\n  }\n}\n\nelse if (source === 'Wellfound') {\n  const urlMatches = [...textContent.matchAll(/wellfound\\.com\\/jobs\\?job_listing_slug=(\\d+[^\\s>\"'\\]]*)/gi)];\n  const jobSlugs = urlMatches.map(m => m[1]);\n\n  const jobPattern = /([A-Za-z][A-Za-z\\s&\\-,\\(\\)]+?(?:Manager|Director|Specialist|Associate|Coordinator|Analyst|Engineer|Representative|Support|Success)(?:[A-Za-z\\s&\\-,\\(\\)]*?))\\s+([A-Z][A-Za-z0-9\\s&\\.\\-']+?)\\s*\\/\\s*(\\d+[-–]\\d+|\\d+\\+?)\\s*Employees/gi;\n\n  let match;\n  let index = 0;\n  while ((match = jobPattern.exec(textContent)) !== null) {\n    const title = match[1].trim();\n    const company = match[2].trim();\n    const size = match[3];\n\n    const afterMatch = textContent.substring(match.index + match[0].length, match.index + match[0].length + 100);\n    const locationMatch = afterMatch.match(/\\|\\s*([^|]+?)(?:\\s*\\||$)/);\n    const location = locationMatch ? locationMatch[1].trim() : 'Remote';\n\n    jobs.push({\n      title: title,\n      company: company,\n      location: location,\n      salary: 'Not specified',\n      source: 'Wellfound',\n      url: jobSlugs[index] ? `https://wellfound.com/jobs?job_listing_slug=${jobSlugs[index]}` : 'https://wellfound.com',\n      jobId: jobSlugs[index] ? `wellfound-${jobSlugs[index].split('-')[0]}` : `wellfound-${Date.now()}-${index}`,\n      _companySize: `${size} Employees`\n    });\n    index++;\n  }\n}\n\nelse if (source === 'Built In') {\n  const builtInUrls = [];\n  const searchContent = htmlContent || textContent;\n  const urlPattern = /https?:\\/\\/(?:www\\.)?builtin\\.com\\/job\\/[^\\s\"'<>]+/gi;\n  let urlMatch;\n  while ((urlMatch = urlPattern.exec(searchContent)) !== null) {\n    builtInUrls.push(urlMatch[0].replace(/&amp;/g, '&'));\n  }\n  const trackingPattern = /href=[\"']([^\"']*builtin[^\"']*job[^\"']*)[\"']/gi;\n  while ((urlMatch = trackingPattern.exec(searchContent)) !== null) {\n    const url = urlMatch[1].replace(/&amp;/g, '&');\n    if (!builtInUrls.includes(url)) builtInUrls.push(url);\n  }\n  \n  let jobIndex = 0;\n  \n  const sectionMatch = textContent.match(/(?:Senior Level|Expert Level|Entry Level|Mid Level)\\s+([\\s\\S]*?)(?:Get More|©|Built In,)/i);\n  if (sectionMatch) {\n    const jobSection = sectionMatch[1].trim();\n    \n    const salaryPattern = /\\$[\\d,]+(?:\\s*-\\s*\\$?[\\d,]+)?/g;\n    const salaries = [];\n    let salaryMatch;\n    while ((salaryMatch = salaryPattern.exec(jobSection)) !== null) {\n      salaries.push({ text: salaryMatch[0], index: salaryMatch.index });\n    }\n    \n    for (let i = 0; i < salaries.length; i++) {\n      const startIdx = i === 0 ? 0 : salaries[i-1].index + salaries[i-1].text.length;\n      const endIdx = salaries[i].index;\n      const jobText = jobSection.substring(startIdx, endIdx).trim();\n      const salary = salaries[i].text;\n      \n      if (jobText.length < 10) continue;\n      \n      const locationPattern = /((?:Remote(?:\\s+[A-Za-z]+)*|[A-Z][a-z]+(?:,\\s*[A-Z]{2})?))\\s*$/;\n      const locMatch = jobText.match(locationPattern);\n      const location = locMatch ? locMatch[1].trim() : 'Not specified';\n      const textWithoutLocation = locMatch ? jobText.substring(0, locMatch.index).trim() : jobText;\n      \n      const titlePattern = /((?:Sr\\.?|Jr\\.?|Senior|Junior|Lead|Staff|Principal|Associate|Manager|Director|VP|Head|Chief|Engineer|Specialist|Coordinator|Representative|Analyst|Consultant|Support|Customer|Digital|Technical)[\\s\\S]*?)$/i;\n      const titleMatch = textWithoutLocation.match(titlePattern);\n      \n      let title = '';\n      let company = '';\n      \n      if (titleMatch) {\n        title = titleMatch[1].trim();\n        company = textWithoutLocation.substring(0, titleMatch.index).trim();\n      } else {\n        const words = textWithoutLocation.split(/\\s+/);\n        if (words.length >= 3) {\n          company = words.slice(0, 2).join(' ');\n          title = words.slice(2).join(' ');\n        }\n      }\n      \n      if (title && company && title.length > 3) {\n        jobs.push({\n          title: title,\n          company: company,\n          location: location,\n          salary: salary,\n          source: 'Built In',\n          url: builtInUrls[jobIndex] || 'https://builtin.com/jobs',\n          jobId: `builtin-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n        });\n        jobIndex++;\n      }\n    }\n  }\n  \n  if (jobs.length === 0) {\n    const atPattern = /([A-Za-z\\s,\\/&]+(?:Support|Success|Director|Manager|Head|VP|Lead|Engineer|Representative|Specialist)[A-Za-z\\s,\\/&]*)\\s+at\\s+([A-Za-z0-9\\s&.,'\\\\-]+?)(?:\\s+in\\s+([A-Za-z\\s,]+?))?(?:\\n|$)/gi;\n    let match;\n    let fallbackIdx = 0;\n    while ((match = atPattern.exec(textContent)) !== null) {\n      jobs.push({\n        title: match[1].trim(),\n        company: match[2].trim(),\n        location: match[3] ? match[3].trim() : 'Not specified',\n        salary: 'Not specified',\n        source: 'Built In',\n        url: builtInUrls[fallbackIdx] || 'https://builtin.com/jobs',\n        jobId: `builtin-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n      });\n      fallbackIdx++;\n    }\n  }\n}\n\nelse if (source === 'Remotive') {\n  let searchContent = htmlContent || textContent;\n\n  searchContent = searchContent\n    .replace(/=\\r?\\n/g, '')\n    .replace(/=([0-9A-Fa-f]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));\n\n  const liPattern = /<li[^>]*>([\\s\\S]*?)<\\/li>/gi;\n  let liMatch;\n\n  while ((liMatch = liPattern.exec(searchContent)) !== null) {\n    const liContent = liMatch[1];\n\n    const urlMatch = liContent.match(/href=[\"']https?:\\/\\/track\\.pstmrk\\.it\\/3s\\/([^\\/]+(?:%2F[^\\/]+)*)\\/eHy2/i);\n    if (!urlMatch) continue;\n\n    const encodedUrl = urlMatch[1];\n\n    let jobUrl;\n    try {\n      jobUrl = 'https://' + decodeURIComponent(encodedUrl);\n    } catch (e) {\n      jobUrl = 'https://' + encodedUrl.replace(/%2F/gi, '/').replace(/%3A/gi, ':');\n    }\n\n    if (jobUrl.includes('remotive.com') && !jobUrl.includes('remote-jobs/')) continue;\n    if (jobUrl.includes('linkedin.com/company')) continue;\n    if (jobUrl.includes('twitter.com')) continue;\n    if (jobUrl.includes('unsubscribe')) continue;\n\n    const titleMatch = liContent.match(/<span[^>]*font-weight:\\s*bold[^>]*>([^<]+)<\\/span>/i);\n    const title = titleMatch ? titleMatch[1].trim() : '';\n\n    const companyMatch = liContent.match(/at\\s*<span[^>]*>([^<]+)<\\/span>/i);\n    const company = companyMatch ? companyMatch[1].trim() : '';\n\n    const locationMatch = liContent.match(/(?:&#x1F4CD;|\\u{1F4CD})\\s*([A-Za-z\\s,]+)/iu);\n    const location = locationMatch ? locationMatch[1].trim() : 'Remote';\n\n    if (title && company) {\n      jobs.push({\n        title: title,\n        company: company,\n        location: location,\n        salary: 'Not specified',\n        source: 'Remotive',\n        url: jobUrl,\n        jobId: `remotive-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n      });\n    }\n  }\n\n  if (jobs.length === 0) {\n    const textPattern = /([A-Za-z][A-Za-z\\s,\\/&\\-]+?(?:Manager|Director|Head|VP|Lead|Engineer|Specialist|Coordinator|Analyst|Representative|Support|Success)[A-Za-z\\s,\\/&]*)\\s+at\\s+([A-Za-z0-9][A-Za-z0-9\\s&.,'\\\\-]+?)(?:\\s*\\u{1F4CD}\\s*([A-Za-z\\s,]+))?(?:\\s|$|Looking)/giu;\n\n    let match;\n    while ((match = textPattern.exec(textContent)) !== null) {\n      jobs.push({\n        title: match[1].trim(),\n        company: match[2].trim(),\n        location: match[3] ? match[3].trim() : 'Remote',\n        salary: 'Not specified',\n        source: 'Remotive',\n        url: 'https://remotive.com/remote-jobs',\n        jobId: `remotive-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n      });\n    }\n  }\n}\n\nelse if (source === 'Indeed') {\n  const indeedUrls = [];\n  const searchContent = htmlContent || textContent;\n\n  const indeedUrlPattern = /https?:\\/\\/(?:[a-z]+\\.)?indeed\\.com\\/(?:viewjob\\?|rc\\/clk\\?|jobs\\?|job\\/)[^\\s\"'<>]+/gi;\n  let urlMatch;\n  while ((urlMatch = indeedUrlPattern.exec(searchContent)) !== null) {\n    indeedUrls.push(urlMatch[0].replace(/&amp;/g, '&'));\n  }\n\n  const trackingPattern = /to\\.indeed\\.com\\/[a-zA-Z0-9]+/gi;\n  while ((urlMatch = trackingPattern.exec(searchContent)) !== null) {\n    indeedUrls.push(`https://${urlMatch[0]}`);\n  }\n\n  const jobPattern = /([A-Za-z\\s,\\/&]+(?:Support|Success|Director|Manager|Head|VP|Lead|Engineer|Representative|Specialist)[A-Za-z\\s,\\/&]*)\\s+at\\s+([A-Za-z0-9\\s&.,'\\\\-]+?)(?:\\s*[-–]\\s*|\\s*\\n|\\s*$)/gi;\n\n  let match;\n  let jobIndex = 0;\n  while ((match = jobPattern.exec(textContent)) !== null) {\n    const salaryMatch = textContent.substring(match.index, match.index + 200).match(/\\$[\\d,]+(?:\\s*[-–]\\s*\\$[\\d,]+)?(?:\\s*(?:\\/|per|a)\\s*(?:year|yr|hour|hr|month))?/i);\n\n    jobs.push({\n      title: match[1].trim(),\n      company: match[2].trim(),\n      location: 'Not specified',\n      salary: salaryMatch ? salaryMatch[0].trim() : 'Not specified',\n      source: 'Indeed',\n      url: indeedUrls[jobIndex] || 'https://indeed.com',\n      jobId: `indeed-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n    });\n    jobIndex++;\n  }\n}\n\nelse if (source === 'Welcome to the Jungle') {\n  let searchContent = htmlContent || textContent;\n  \n  searchContent = searchContent\n    .replace(/=\\r?\\n/g, '')\n    .replace(/=3D/g, '=')\n    .replace(/=([0-9A-Fa-f]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));\n  \n  const jobBlocks = [];\n  const blockPattern = /<a[^>]*href=[\"']?(https:\\/\\/[^\"'\\s]*(?:sendgrid\\.net|ct\\.sendgrid\\.net)\\/ls\\/click[^\"'\\s]*)[\"']?[^>]*>[\\s\\S]*?<\\/a>/gi;\n  \n  let blockMatch;\n  while ((blockMatch = blockPattern.exec(searchContent)) !== null) {\n    const url = blockMatch[1];\n    const content = blockMatch[0];\n    \n    if (content.includes('Jungle logo') || content.includes('unsubscribe') || content.includes('manage your')) continue;\n    if (!content.includes('Salary:')) continue;\n    \n    jobBlocks.push({ url, content });\n  }\n  \n  const seenJobs = new Set();\n  \n  for (const block of jobBlocks) {\n    const strongMatches = [...block.content.matchAll(/<strong>([^<]+)<\\/strong>/gi)];\n    let company = '';\n    let title = '';\n    \n    for (const sm of strongMatches) {\n      const text = sm[1].trim();\n      if (!text || text.length < 2) continue;\n      if (text.toLowerCase().includes('jungle')) continue;\n      \n      if (!company) {\n        company = text;\n      } else if (!title) {\n        title = text;\n        break;\n      }\n    }\n    \n    const salaryMatch = block.content.match(/Salary:\\s*(\\$[\\d,]+(?:\\s*[-–]\\s*\\$?[\\d,]+)?K?)/i);\n    const salary = salaryMatch ? salaryMatch[1].trim() : 'Not specified';\n    \n    const locationMatch = block.content.match(/(?:Remote|Hybrid|On-?site)[^<]*(?:\\([^)]+\\))?/i);\n    const location = locationMatch ? locationMatch[0].trim() : 'Not specified';\n    \n    if (title && company) {\n      const key = `${title.toLowerCase()}-${company.toLowerCase()}`;\n      if (seenJobs.has(key)) continue;\n      seenJobs.add(key);\n      \n      jobs.push({\n        title: title,\n        company: company,\n        location: location,\n        salary: salary,\n        source: 'Welcome to the Jungle',\n        url: block.url,\n        jobId: `wttj-${Date.now()}-${jobs.length}`\n      });\n    }\n  }\n}\n\nelse if (source === 'Google Careers') {\n  let searchContent = htmlContent || textContent;\n  searchContent = searchContent\n    .replace(/=\\r?\\n/g, '')\n    .replace(/=3D/g, '=')\n    .replace(/=([0-9A-Fa-f]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));\n  \n  const jobPattern = /href=([\"']?)https:\\/\\/www\\.google\\.com\\/about\\/careers\\/applications\\/jobs\\/results\\/(\\d+)-([^?\\s\"']+)[^>]*>[\\s\\S]*?<u>([^<]+)<\\/u>[\\s\\S]*?Google[\\s&;nbsp;]*[–-][\\s&;nbsp;]*([^<]+?)(?:<br|<\\/span)/gi;\n  \n  let match;\n  const seenIds = new Set();\n  \n  while ((match = jobPattern.exec(searchContent)) !== null) {\n    const jobId = match[2];\n    if (seenIds.has(jobId)) continue;\n    seenIds.add(jobId);\n    \n    const slug = match[3];\n    const title = match[4].trim();\n    let location = match[5].trim()\n      .replace(/&nbsp;/g, ' ')\n      .replace(/&ndash;/g, '-')\n      .replace(/<[^>]+>/g, '')\n      .trim();\n    \n    if (location.toLowerCase().includes('yesterday') || location.toLowerCase().includes('days ago')) {\n      location = location.replace(/yesterday|\\d+ days? ago/gi, '').trim();\n    }\n    if (!location || location.length < 2) location = 'Multiple Sites';\n    \n    const url = `https://www.google.com/about/careers/applications/jobs/results/${jobId}-${slug}`;\n    \n    if (title) {\n      jobs.push({\n        title: title,\n        company: 'Google',\n        location: location,\n        salary: 'Not specified',\n        source: 'Google Careers',\n        url: url,\n        jobId: `google-${jobId}`\n      });\n    }\n  }\n}\n\nelse if (source === 'Jobright') {\n  let searchContent = htmlContent || textContent;\n  searchContent = searchContent\n    .replace(/=\\r?\\n/g, '')\n    .replace(/=3D/g, '=')\n    .replace(/=([0-9A-Fa-f]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));\n  \n  const isSalaryTag = (tag) => /\\$\\d|\\d+K\\/yr/i.test(tag);\n  const isIgnoredTag = (tag) => /referral|applicant|posted|ago|alumni|early applicant/i.test(tag);\n  \n  const seenUrls = new Set();\n  \n  const tablePattern = /<table[^>]*border-radius:\\s*16px[^>]*>[\\s\\S]*?<\\/table>/gi;\n  const jobTables = searchContent.match(tablePattern) || [];\n  \n  for (const table of jobTables) {\n    if (!table.includes('APPLY NOW') && !table.includes('jobright.ai/jobs/info')) continue;\n    \n    const urlMatch = table.match(/href=[\"\\']?(https:\\/\\/jobright\\.ai\\/jobs\\/info\\/[a-f0-9]+)/i);\n    if (!urlMatch) continue;\n    const url = urlMatch[1].trim();\n    if (seenUrls.has(url)) continue;\n    seenUrls.add(url);\n    \n    const titleMatch = table.match(/font-size:\\s*16px;\\s*font-weight:\\s*640[^>]*>\\s*([^<]+)/i);\n    const title = titleMatch ? titleMatch[1].trim() : '';\n    \n    const companyMatch = table.match(/font-size:\\s*13px;\\s*font-weight:\\s*500[^>]*>\\s*([^<]+)/i);\n    const company = companyMatch ? companyMatch[1].trim() : '';\n    \n    const tagPattern = /background:\\s*#f2f4f5[^>]*>\\s*([^<]+)/gi;\n    const tags = [];\n    let tagMatch;\n    while ((tagMatch = tagPattern.exec(table)) !== null) {\n      tags.push(tagMatch[1].trim());\n    }\n    \n    let salary = 'Not specified';\n    let location = 'Not specified';\n    \n    for (const tag of tags) {\n      if (isSalaryTag(tag)) {\n        salary = tag;\n      } else if (tag.length > 0 && !isIgnoredTag(tag)) {\n        location = tag;\n      }\n    }\n    \n    if (title && company) {\n      jobs.push({\n        title: title,\n        company: company,\n        location: location,\n        salary: salary,\n        source: 'Jobright',\n        url: url,\n        jobId: `jobright-${url.split('/').pop()}`\n      });\n    }\n  }\n}\n\nelse if (source === 'Bloomberry') {\n  let searchContent = htmlContent || textContent;\n  \n  // Decode quoted-printable\n  searchContent = searchContent\n    .replace(/=\\r?\\n/g, '')\n    .replace(/=3D/g, '=')\n    .replace(/=([0-9A-Fa-f]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));\n  \n  // Pattern: <number>) <b><a href=\"URL\">Title</a></b> (Location), Company - <i> Salary</i>\n  // Note: URLs may have extra }\" at the end due to typos in source\n  const jobPattern = /\\d+\\)\\s*<b><a\\s+href=[\"']?([^\"'>}]+)[}\"']*[^>]*>([^<]*)<\\/a><\\/b>\\s*\\(([^)]+)\\),\\s*([^<-]+?)(?:\\s*-\\s*<i>\\s*([^<]+)<\\/i>)?/gi;\n  \n  let match;\n  const seenJobs = new Set();\n  \n  while ((match = jobPattern.exec(searchContent)) !== null) {\n    const url = match[1].trim();\n    let title = match[2].trim();\n    const location = match[3].trim();\n    const company = match[4].trim();\n    const salary = match[5] ? match[5].trim() : 'Not specified';\n    \n    // Skip if no title in anchor tag (some jobs have empty anchor)\n    if (!title || title.length < 3) continue;\n    \n    // Skip unsubscribe and other non-job links\n    if (url.includes('unsubscribe') || url.includes('bloomberry.com/blog')) continue;\n    \n    const key = `${title.toLowerCase()}-${company.toLowerCase()}`;\n    if (seenJobs.has(key)) continue;\n    seenJobs.add(key);\n    \n    jobs.push({\n      title: title,\n      company: company,\n      location: location,\n      salary: salary,\n      source: 'Bloomberry',\n      url: url,\n      jobId: `bloomberry-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n    });\n  }\n}\n\nelse {\n  const atPattern = /([A-Za-z\\s,\\/&]+(?:Support|Success|Director|Manager|Head|VP|Lead|Engineer)[A-Za-z\\s,\\/&]*)\\s+at\\s+([A-Za-z0-9\\s&.,'\\\\-]+)/gi;\n  let match;\n  while ((match = atPattern.exec(textContent)) !== null) {\n    jobs.push({\n      title: match[1].trim(),\n      company: match[2].trim(),\n      location: 'Not specified',\n      salary: 'Not specified',\n      source: source,\n      url: '',\n      jobId: `other-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n    });\n  }\n}\n\n} catch (e) {\n  parserError = { source: source, error: e.message };\n}\n\n  const seen = new Set();\n  const uniqueJobs = jobs.filter(job => {\n    const key = `${job.title.toLowerCase()}-${job.company.toLowerCase()}`;\n    if (seen.has(key)) return false;\n    seen.add(key);\n    return true;\n  });\n\n  const emailId = email.id || '';\n  if (uniqueJobs.length === 0) {\n    allJobs.push({ _noJobs: true, _source: source, _rawText: (textContent || '').substring(0, 500), _emailId: emailId, _parserError: parserError });\n  } else {\n    for (const job of uniqueJobs) {\n      allJobs.push({\n        title: job.title,\n        company: job.company,\n        location: job.location,\n        salary: job.salary,\n        source: job.source,\n        url: job.url,\n        jobId: job.jobId,\n        _dateFound: new Date().toISOString().split('T')[0],\n        _emailId: emailId\n      });\n    }\n  }\n}\n\nif (allJobs.length === 0) {\n  return [{ json: { _noJobs: true, _source: 'None' } }];\n}\n\nreturn allJobs.map(job => ({ json: job }));"
      },
      "id": "b5ddecf4-282a-48da-b27e-49864a4bcf50",
      "name": "Parse Jobs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json._noJobs }}",
              "operation": "notEqual",
              "value2": true
            }
          ]
        }
      },
      "id": "e9793cf8-98f5-44e7-8d2b-c80623d3fd9a",
      "name": "Has Jobs",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [900, 300],
      "executeOnce": false
    },
    {
      "parameters": {
        "authentication": "airtableTokenApi",
        "operation": "append",
        "application": "appFEzXvPWvRtXgRY",
        "table": "tbl6ZV2rHjWz56pP3",
        "addAllFields": false,
        "fields": [
          "Job Title",
          "Company",
          "Location",
          "Source",
          "Job URL",
          "Job ID",
          "Salary Info",
          "Date Found",
          "Review Status",
          "Tide-Pool Score",
          "Tide-Pool Rationale",
          "Company Stage",
          "Industry",
          "Role Type",
          "Builder Evidence",
          "Maintainer Evidence",
          "Recommendation"
        ],
        "options": {}
      },
      "id": "61fe9dc4-02f6-4310-82c1-e550e3d54c14",
      "name": "Add to Airtable",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 1,
      "position": [2460, 200]
    },
    {
      "parameters": {},
      "id": "08ac338a-2a9d-4ebe-b9fc-154d347300af",
      "name": "No Jobs Found",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [1120, 400]
    },
    {
      "parameters": {
        "jsCode": "// Transform field names to match Airtable exactly\n// Filter to only customer support/success leadership roles\n\nconst items = $input.all().filter(item => !item.json._empty);\n\nif (items.length === 0) {\n  return [{ json: { _empty: true } }];\n}\n\n// Role filter: must contain support/success keywords AND leadership keywords\nconst supportKeywords = ['support', 'success', 'customer', 'client', 'cx', 'experience'];\nconst leadershipKeywords = ['manager', 'director', 'vp', 'vice president', 'head', 'lead', 'chief', 'supervisor', 'team lead'];\n\nconst filteredItems = items.filter(item => {\n  const title = (item.json.title || '').toLowerCase();\n  \n  // Check if title contains any support/success keyword\n  const hasSupport = supportKeywords.some(kw => title.includes(kw));\n  \n  // Check if title contains any leadership keyword\n  const hasLeadership = leadershipKeywords.some(kw => title.includes(kw));\n  \n  return hasSupport && hasLeadership;\n});\n\nif (filteredItems.length === 0) {\n  return [{ json: { _empty: true } }];\n}\n\nreturn filteredItems.map(item => ({\n  json: {\n    \"Job Title\": item.json.title,\n    \"Company\": item.json.company,\n    \"Location\": item.json.location,\n    \"Source\": item.json.source,\n    \"Job URL\": item.json.url,\n    \"Job ID\": item.json.jobId,\n    \"Salary Info\": item.json.salary,\n    \"Date Found\": item.json._dateFound,\n    \"Review Status\": \"New\",\n    \"_emailId\": item.json._emailId\n  }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 200],
      "id": "98d38b91-2e59-41fd-a90a-a96f7285cd8a",
      "name": "Map Fields for Airtable"
    },
    {
      "parameters": {}
      ,
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [1120, 200],
      "id": "1480342c-fdf4-4f39-9d7d-b4af1fb57f3d",
      "name": "Merge Inputs"
    },
    {
      "parameters": {
        "operation": "getAll",
        "limit": 10,
        "simple": false,
        "filters": {
          "q": "is:unread in:inbox from:(jobs-listings@linkedin.com OR jobalerts-noreply@linkedin.com OR jobs-noreply@linkedin.com OR builtin.com OR wellfound.com OR himalayas.app OR remotive.com OR welcometothejungle.com OR jobright.ai OR careers-noreply@google.com OR bloomberry.com) newer_than:21d"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [240, 300],
      "id": "030c0710-e8b5-4592-b8f3-921cb84c2ee5",
      "name": "Get many messages",
      "webhookId": "46595c63-cee2-41ff-834e-8114edf3d651"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.3,
      "position": [20, 300],
      "id": "e1fb5522-3c97-46bc-b12d-f7ab42cb5efe",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "operation": "addLabels",
        "messageId": "={{ $('Filter Empty').item.json._emailId }}",
        "labelIds": [
          "Label_3146569228785124450"
        ]
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [2680, 200],
      "id": "9da1f2f0-7853-49f4-a237-d67560038f17",
      "name": "Add label to message",
      "webhookId": "a29818cc-9d22-40cb-ad01-47c3f481b26c"
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "value": "appFEzXvPWvRtXgRY",
          "mode": "list",
          "cachedResultName": "Job search",
          "cachedResultUrl": "https://airtable.com/appFEzXvPWvRtXgRY"
        },
        "table": {
          "__rl": true,
          "value": "tbl6ZV2rHjWz56pP3",
          "mode": "list",
          "cachedResultName": "Job Listings",
          "cachedResultUrl": "https://airtable.com/appFEzXvPWvRtXgRY/tbl6ZV2rHjWz56pP3"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [680, 500],
      "id": "354023d1-d41c-4a6f-a0a2-f65c3c1b95aa",
      "name": "Search records"
    },
    {
      "parameters": {
        "jsCode": "// Dedup Code v2 - More aggressive normalization\n\nconst normalize = (str) => {\n  if (!str) return '';\n  return str\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s]/g, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\n};\n\nconst allItems = $input.all();\n\nconst newJobs = allItems.filter(item => \n  item.json.title && item.json.source && !item.json.fields && !item.json[\"Job Title\"]\n);\n\nconst existingRecords = allItems.filter(item => \n  item.json.fields || item.json[\"Job Title\"] || (item.json[\"Job URL\"] && !item.json.source)\n);\n\nconst existingUrls = new Set();\nconst existingKeys = new Set();\n\nfor (const item of existingRecords) {\n  const fields = item.json.fields || item.json;\n  \n  let url = fields[\"Job URL\"] || \"\";\n  if (url) {\n    url = url.split('?')[0].replace(/\\/$/, '');\n    existingUrls.add(url);\n  }\n  \n  const title = normalize(fields[\"Job Title\"] || \"\");\n  const company = normalize(fields[\"Company\"] || \"\");\n  if (title && company) {\n    existingKeys.add(title + \"|\" + company);\n  }\n}\n\nconst results = [];\n\nfor (const job of newJobs) {\n  let url = job.json.url || \"\";\n  if (url) {\n    url = url.split('?')[0].replace(/\\/$/, '');\n  }\n  \n  const title = normalize(job.json.title || \"\");\n  const company = normalize(job.json.company || \"\");\n  const key = title + \"|\" + company;\n  \n  const isGenericUrl = url.endsWith('/jobs') || url.endsWith('/remote-jobs');\n  if (url && !isGenericUrl && existingUrls.has(url)) continue;\n  \n  if (existingKeys.has(key)) continue;\n  \n  if (url && !isGenericUrl) existingUrls.add(url);\n  existingKeys.add(key);\n  \n  results.push(job);\n}\n\nreturn results.length ? results : [{ json: { _empty: true } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 0],
      "id": "e2ee93e7-b6d3-4e0d-901b-187ad46badc7",
      "name": "Dedup Against Airtable"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json._empty }}",
              "operation": "notEqual",
              "value2": true
            }
          ]
        }
      },
      "id": "19a4a8ee-493b-48d4-a772-f93dccf6672c",
      "name": "Filter Empty",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2460, 0]
    },
    {
      "parameters": {
        "operation": "markAsRead",
        "messageId": "={{ $json.id }}"
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [350, 300],
      "id": "44a4722e-ebae-436a-a463-94533a4eaec9",
      "name": "Mark as Read",
      "webhookId": "db2ff5fd-2d5a-46b4-99db-280fc676c78d"
    },
    {
      "parameters": {
        "url": "https://raw.githubusercontent.com/zelman/tidepool/refs/heads/main/tide-pool-agent-lens.md",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1780, 200],
      "id": "446a4263-1637-4cdf-a73f-33ae2adc793a",
      "name": "Fetch Profile"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Builder vs Maintainer Pre-Filter\n// Quick signal check before expensive LLM calls\n\nconst CONFIG = {\n  minBuilderSignals: 1,\n  maxMaintainerSignals: 3,\n  maxCompanySize: 500,\n  seniorityRequired: [\"head\", \"director\", \"vp\", \"vice president\", \"chief\", \"lead\"],\n  minBaseSalary: 125000,\n};\n\nconst BUILDER_SIGNALS = [\n  \"build from scratch\", \"building the function\", \"first hire\", \"founding team\",\n  \"ground floor\", \"greenfield\", \"no playbook\", \"define the playbook\",\n  \"create the playbook\", \"build the team\", \"stand up\", \"establish the foundation\",\n  \"series a\", \"series b\", \"seed stage\", \"early stage\", \"early-stage\",\n  \"startup\", \"hypergrowth\", \"wear many hats\", \"player-coach\", \"hands-on leader\",\n  \"roll up your sleeves\", \"scrappy\", \"ambiguity\", \"build processes\",\n  \"define processes\", \"voice of customer\", \"growth lever\", \"strategic partner\",\n  \"report to ceo\", \"report to founder\", \"exec team\"\n];\n\nconst MAINTAINER_SIGNALS = [\n  \"book of business\", \"portfolio of accounts\", \"manage your accounts\",\n  \"own a portfolio\", \"retention targets\", \"renewal rate\", \"net retention\",\n  \"gross retention\", \"nrr\", \"grr\", \"churn reduction\", \"upsell quota\",\n  \"expansion targets\", \"expansion revenue\", \"cross-sell\", \"established processes\",\n  \"proven playbook\", \"existing team of\", \"maintain existing\", \"support the team\",\n  \"customer success manager\", \"manage relationships\", \"own the relationship\",\n  \"point of contact for\"\n];\n\nconst TITLE_EXCLUDES = [\n  \"customer success manager\", \"csm\", \"account manager\", \"account executive\",\n  \"representative\", \"specialist\", \"associate\", \"coordinator\", \"analyst\"\n];\n\nfunction countSignals(text, signals) {\n  return signals.filter(signal => text.includes(signal)).length;\n}\n\nfunction estimateRoleType(builder, maintainer) {\n  const ratio = builder / Math.max(1, maintainer);\n  if (ratio >= 2) return 'likely_builder';\n  if (ratio >= 1) return 'hybrid';\n  if (ratio >= 0.5) return 'leaning_maintainer';\n  return 'likely_maintainer';\n}\n\nconst jobData = $json;\n\n// Skip empty items\nif (jobData._empty) {\n  return { json: { ...jobData, _skip: true } };\n}\n\nconst title = (jobData['Job Title'] || '').toLowerCase();\nconst description = ''; // We don't have full description at this stage, just title\nconst text = title;\n\n// Count signals from title only (description comes later from LLM)\nconst builderCount = countSignals(text, BUILDER_SIGNALS);\nconst maintainerCount = countSignals(text, MAINTAINER_SIGNALS);\n\n// Check title exclusions\nconst hasBadTitle = TITLE_EXCLUDES.some(exc => title.includes(exc));\n\n// Check seniority\nconst hasSeniority = CONFIG.seniorityRequired.some(level => title.includes(level));\n\n// Decision logic - since we only have title, be more permissive\nlet shouldProcess = true;\nlet reason = null;\n\n// Only hard reject obvious IC titles without seniority\nif (hasBadTitle && !hasSeniority) {\n  shouldProcess = false;\n  reason = `IC title (${title}) without leadership level`;\n}\n\nconst prefilterAnalysis = {\n  shouldProcess,\n  reason,\n  builderSignals: builderCount,\n  maintainerSignals: maintainerCount,\n  signalRatio: builderCount / Math.max(1, maintainerCount),\n  hasSeniority,\n  estimatedRoleType: estimateRoleType(builderCount, maintainerCount)\n};\n\nreturn {\n  json: {\n    ...jobData,\n    prefilterAnalysis\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 200],
      "id": "prefilter-node-001",
      "name": "Prefilter: Builder vs Maintainer"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.prefilterAnalysis.shouldProcess }}",
              "value2": true
            }
          ]
        }
      },
      "id": "prefilter-if-node-001",
      "name": "IF: Should Process",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1670, 200]
    },
    {
      "parameters": {},
      "id": "skip-filtered-node-001",
      "name": "Skip Filtered Jobs",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [1670, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build comprehensive prompt for Claude API - DYNAMICALLY from Tide Pool profile\nconst jobData = $('IF: Should Process').item.json;\nconst profileRaw = $('Fetch Profile').first().json.data || $('Fetch Profile').first().json;\n\n// Get the profile content as string\nconst profileContent = typeof profileRaw === 'string' ? profileRaw : JSON.stringify(profileRaw);\n\n// Get API key from Airtable Config\nconst configData = $('Get Config').first().json;\nconst apiKey = configData.fields?.Value || configData.Value || '';\n\n// Skip empty items\nif (jobData._empty || jobData._skip) {\n  return { json: { ...jobData, _skip: true } };\n}\n\n// Build system prompt dynamically from the fetched Tide Pool profile\nconst systemPrompt = `You are a job matching assistant. Use the following personal profile to evaluate job opportunities.\n\n=== CANDIDATE PROFILE (Tide Pool Agent Lens) ===\n${profileContent}\n=== END PROFILE ===\n\n## Your Task\nAnalyze the job posting against the profile above. Pay special attention to:\n1. The \"Job Search Parameters\" section for ideal company fit criteria\n2. The \"Auto-Disqualifiers\" - these are HARD NO criteria\n3. The \"Opportunity Scoring Framework\" for how to score\n4. The \"Role Type Exclusions\" section\n5. The \"Title Flexibility\" guidance for early-stage companies\n\n## Critical Distinction: BUILDER vs MAINTAINER\nThis candidate wants BUILDER roles (creating from scratch) NOT MAINTAINER roles (managing existing).\n\n**BUILDER signals:** build from scratch, first hire, founding team, greenfield, define playbook, series A/B, startup, player-coach, hands-on\n**MAINTAINER signals:** book of business, portfolio of accounts, retention targets, renewal rate, established processes, proven playbook\n\n## Response Format\nRespond with ONLY valid JSON:\n{\n  \"score\": <0-100 using the scoring framework from profile>,\n  \"role_type\": \"builder\" | \"maintainer\" | \"hybrid\",\n  \"is_dealbreaker\": <true/false based on auto-disqualifiers>,\n  \"dealbreaker_reason\": \"<reason if dealbreaker, null otherwise>\",\n  \"score_breakdown\": {\n    \"company_stage_fit\": <0-50>,\n    \"role_type\": <0-30>,\n    \"mission_alignment\": <0-20>\n  },\n  \"builder_evidence\": [<quotes/signals suggesting builder role>],\n  \"maintainer_evidence\": [<quotes/signals suggesting maintainer role>],\n  \"industry\": \"<company's industry>\",\n  \"company_stage_detected\": \"<pre_a|series_a|series_b|series_c|growth|late|unknown>\",\n  \"company_size_detected\": \"<number or range if mentioned, null if not>\",\n  \"salary_detected\": { \"base_min\": <number or null>, \"base_max\": <number or null>, \"has_equity\": <true/false/null> },\n  \"what_excites\": [<aspects that align with profile>],\n  \"concerns\": [<red flags or misalignments>],\n  \"recommendation\": \"apply\" | \"research\" | \"skip\",\n  \"summary\": \"<2-3 sentence assessment focused on builder vs maintainer fit>\"\n}`;\n\n// Include prefilter analysis in the prompt\nconst prefilterInfo = jobData.prefilterAnalysis ? \n  `\\n\\nPREFILTER ANALYSIS (from title only):\\n- Estimated role type: ${jobData.prefilterAnalysis.estimatedRoleType}\\n- Has seniority: ${jobData.prefilterAnalysis.hasSeniority}` : '';\n\nconst userPrompt = `Analyze this job posting using the Tide Pool profile criteria above.${prefilterInfo}\n\nJOB POSTING:\nTitle: ${jobData['Job Title']}\nCompany: ${jobData['Company']}\nLocation: ${jobData['Location']}\nSalary: ${jobData['Salary Info']}\nSource: ${jobData['Source']}\n\nNote: Full job description not available - analyze based on title and any company context you may know.\n\nApply the scoring framework from the profile and return JSON.`;\n\nreturn {\n  json: {\n    ...jobData,\n    _systemPrompt: systemPrompt,\n    _userPrompt: userPrompt,\n    _apiKey: apiKey\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 200],
      "id": "028a991e-b605-4e0f-9bac-86da28eed233",
      "name": "Build Prompt"
    },
    {
      "parameters": {
        "amount": 10
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [2110, 200],
      "id": "40f14142-568f-43d9-8d4c-abdf04587c0e",
      "name": "Wait (Rate Limit)",
      "webhookId": "rate-limit-wait"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $json._apiKey }}"
            },
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"claude-3-haiku-20240307\",\n  \"max_tokens\": 2000,\n  \"system\": {{ JSON.stringify($json._systemPrompt) }},\n  \"messages\": [{\"role\": \"user\", \"content\": {{ JSON.stringify($json._userPrompt) }}}]\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2220, 200],
      "id": "07b4e26d-c2f5-49a8-a04d-4845aca9c016",
      "name": "Call Claude API",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Parse Claude response - Robust JSON parsing\nconst input = $json;\nconst jobData = $('Build Prompt').item.json;\n\n// Skip if marked to skip\nif (jobData._skip) {\n  return { json: jobData };\n}\n\nlet fitScore = 0;\nlet fitRationale = 'Unable to rate';\nlet industry = '';\nlet companyStage = '';\nlet roleType = '';\nlet builderEvidence = '';\nlet maintainerEvidence = '';\nlet recommendation = '';\n\n// Helper to safely extract JSON from text\nfunction extractJSON(text) {\n  // Try to find balanced braces\n  let depth = 0;\n  let start = -1;\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] === '{') {\n      if (depth === 0) start = i;\n      depth++;\n    } else if (text[i] === '}') {\n      depth--;\n      if (depth === 0 && start !== -1) {\n        return text.substring(start, i + 1);\n      }\n    }\n  }\n  return null;\n}\n\ntry {\n  if (input.content && input.content[0] && input.content[0].text) {\n    const content = input.content[0].text;\n    const jsonStr = extractJSON(content);\n    \n    if (jsonStr) {\n      // Clean up common JSON issues\n      const cleaned = jsonStr\n        .replace(/,\\s*}/g, '}')  // trailing commas\n        .replace(/,\\s*]/g, ']')  // trailing commas in arrays\n        .replace(/\\n/g, ' ')     // newlines\n        .replace(/\\t/g, ' ');    // tabs\n      \n      const parsed = JSON.parse(cleaned);\n      \n      // Extract main fields\n      fitScore = parsed.score || 0;\n      roleType = parsed.role_type || '';\n      recommendation = parsed.recommendation || '';\n      \n      // Build rationale from summary\n      fitRationale = parsed.summary || 'No summary provided';\n      \n      // Extract company info\n      companyStage = parsed.company_stage_detected || '';\n      industry = parsed.industry || '';\n      \n      // Format evidence arrays as strings (handle non-arrays gracefully)\n      if (parsed.builder_evidence) {\n        const arr = Array.isArray(parsed.builder_evidence) ? parsed.builder_evidence : [parsed.builder_evidence];\n        builderEvidence = arr.slice(0, 3).join('; ');\n      }\n      if (parsed.maintainer_evidence) {\n        const arr = Array.isArray(parsed.maintainer_evidence) ? parsed.maintainer_evidence : [parsed.maintainer_evidence];\n        maintainerEvidence = arr.slice(0, 3).join('; ');\n      }\n      \n      // Add dealbreaker info to rationale if applicable\n      if (parsed.is_dealbreaker && parsed.dealbreaker_reason) {\n        fitRationale = `DEALBREAKER: ${parsed.dealbreaker_reason}. ${fitRationale}`;\n      }\n    } else {\n      fitRationale = 'Could not extract JSON from response';\n    }\n  } else if (input.error) {\n    fitRationale = 'API Error: ' + (input.error.message || JSON.stringify(input.error));\n  }\n} catch (e) {\n  fitRationale = 'Parse Error: ' + e.message;\n}\n\n// Remove internal fields before returning\nconst { _systemPrompt, _userPrompt, _skip, _apiKey, prefilterAnalysis, ...cleanJobData } = jobData;\n\nreturn {\n  json: {\n    ...cleanJobData,\n    'Tide-Pool Score': fitScore,\n    'Tide-Pool Rationale': fitRationale,\n    'Industry': industry,\n    'Company Stage': companyStage,\n    'Role Type': roleType,\n    'Builder Evidence': builderEvidence,\n    'Maintainer Evidence': maintainerEvidence,\n    'Recommendation': recommendation\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2330, 200],
      "id": "1650c7a3-4c20-43e2-b7b8-e27d526b7c4e",
      "name": "Parse Response"
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "value": "appFEzXvPWvRtXgRY",
          "mode": "list",
          "cachedResultName": "Job search",
          "cachedResultUrl": "https://airtable.com/appFEzXvPWvRtXgRY"
        },
        "table": {
          "__rl": true,
          "value": "tblofzQpzGEN8igVS",
          "mode": "id"
        },
        "filterByFormula": "{Key} = 'ANTHROPIC_API_KEY'",
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [680, 100],
      "id": "89d54fe3-9090-4242-9304-46a2078e53f7",
      "name": "Get Config"
    }
  ],
  "connections": {
    "Identify Source": {
      "main": [
        [
          {
            "node": "Parse Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Jobs": {
      "main": [
        [
          {
            "node": "Has Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Jobs": {
      "main": [
        [
          {
            "node": "Merge Inputs",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Jobs Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Fields for Airtable": {
      "main": [
        [
          {
            "node": "Prefilter: Builder vs Maintainer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prefilter: Builder vs Maintainer": {
      "main": [
        [
          {
            "node": "IF: Should Process",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF: Should Process": {
      "main": [
        [
          {
            "node": "Fetch Profile",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip Filtered Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Profile": {
      "main": [
        [
          {
            "node": "Build Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Prompt": {
      "main": [
        [
          {
            "node": "Wait (Rate Limit)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait (Rate Limit)": {
      "main": [
        [
          {
            "node": "Call Claude API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Claude API": {
      "main": [
        [
          {
            "node": "Parse Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Response": {
      "main": [
        [
          {
            "node": "Filter Empty",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get many messages": {
      "main": [
        [
          {
            "node": "Mark as Read",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark as Read": {
      "main": [
        [
          {
            "node": "Identify Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Get many messages",
            "type": "main",
            "index": 0
          },
          {
            "node": "Search records",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add to Airtable": {
      "main": [
        [
          {
            "node": "Add label to message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search records": {
      "main": [
        [
          {
            "node": "Merge Inputs",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Inputs": {
      "main": [
        [
          {
            "node": "Dedup Against Airtable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dedup Against Airtable": {
      "main": [
        [
          {
            "node": "Map Fields for Airtable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Empty": {
      "main": [
        [
          {
            "node": "Add to Airtable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "tags": []
}
