{
  "name": "Work at a Startup Scraper",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 6
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.3,
      "position": [-800, 0],
      "id": "schedule-trigger",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "value": "appFEzXvPWvRtXgRY",
          "mode": "id"
        },
        "table": {
          "__rl": true,
          "value": "tblofzQpzGEN8igVS",
          "mode": "id"
        },
        "filterByFormula": "OR({Key} = 'YC_USER', {Key} = 'YC_PASSWORD', {Key} = 'BROWSERLESS_TOKEN', {Key} = 'ANTHROPIC_API_KEY')",
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [-600, 0],
      "id": "get-config",
      "name": "Get Config",
      "credentials": {
        "airtableTokenApi": {
          "id": "sempBDy7tuv1mA6y",
          "name": "Airtable Personal Access Token account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Extract config values\nconst items = $input.all();\nconst config = {};\n\nfor (const item of items) {\n  const key = item.json.fields?.Key || item.json.Key;\n  const value = item.json.fields?.Value || item.json.Value;\n  if (key && value) {\n    config[key] = value;\n  }\n}\n\nreturn [{ json: config }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-400, 0],
      "id": "parse-config",
      "name": "Parse Config"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://chrome.browserless.io/function?token={{ $json.BROWSERLESS_TOKEN }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ context: { ycUser: $json.YC_USER, ycPassword: $json.YC_PASSWORD }, code: `export default async ({ page, context }) => { const { ycUser, ycPassword } = context; const jobsUrl = 'https://www.workatastartup.com/companies?demographic=any&hasEquity=any&hasSalary=any&industry=any&interviewProcess=any&jobType=any&layout=list-compact&role=support&sortBy=keyword&tab=any&usVisaNotRequired=any'; const sleep = ms => new Promise(r => setTimeout(r, ms)); try { const authUrl = 'https://account.ycombinator.com/authenticate?continue=' + encodeURIComponent(jobsUrl); await page.goto(authUrl, { waitUntil: 'networkidle2', timeout: 30000 }); if (page.url().includes('account.ycombinator.com')) { await page.waitForSelector('#ycid-input', { timeout: 10000 }); await page.type('#ycid-input', ycUser); await page.type('#password-input', ycPassword); await page.click('button[type=\"submit\"]'); await sleep(8000); } if (!page.url().includes('workatastartup.com')) { await page.goto(jobsUrl, { waitUntil: 'networkidle2', timeout: 30000 }); await sleep(3000); } for (let i = 0; i < 5; i++) { await page.evaluate(() => window.scrollTo(0, document.body.scrollHeight)); await sleep(2000); } const jobs = await page.evaluate(() => { const results = []; const jobLinks = document.querySelectorAll('a[href*=\"/jobs/\"]'); const seen = new Set(); jobLinks.forEach((jobLink, idx) => { try { const href = jobLink.getAttribute('href'); if (seen.has(href)) return; seen.add(href); const title = jobLink.innerText.trim(); if (title === 'View job') return; let company = 'Unknown'; let ycBatch = ''; let location = 'Not specified'; let salary = 'Not specified'; let industry = ''; let parent = jobLink.parentElement; for (let i = 0; i < 10 && parent; i++) { const text = parent.innerText || ''; if (text.includes('(S') || text.includes('(W') || text.includes('(F')) { const match = text.match(/([A-Za-z0-9\\\\s\\\\.]+)\\\\s*\\\\(([SWF][0-9]+)\\\\)/); if (match) { company = match[1].trim(); ycBatch = 'YC ' + match[2]; break; } } parent = parent.parentElement; } parent = jobLink.parentElement; for (let i = 0; i < 10 && parent; i++) { const text = parent.innerText || ''; const locMatch = text.match(/(San Francisco|New York|Remote|Los Angeles|Seattle|Austin|Boston|Chicago|Denver|Miami|London|Berlin|Atlanta)/i); if (locMatch) { location = locMatch[0]; break; } const indMatch = text.match(/(B2B Software|Healthcare|Fintech|Financial Technology|Consumer|E-commerce|Education|AI|Machine Learning|Developer Tools|SaaS|Marketplace|Logistics|Real Estate|Insurance|Legal|Security|Infrastructure)/i); if (indMatch && !industry) { industry = indMatch[0]; } parent = parent.parentElement; } const url = href.startsWith('http') ? href : 'https://www.workatastartup.com' + href; if (title && title.length > 3) { results.push({ title, company, ycBatch, industry, location, salary, url, source: 'Work at a Startup', jobId: 'waas-' + Date.now() + '-' + idx }); } } catch(e) {} }); return results; }); return { type: 'application/json', data: jobs }; } catch (error) { return { type: 'application/json', data: [{ error: error.message }] }; } };` }) }}",
        "options": {
          "timeout": 120000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [-200, 0],
      "id": "browserless-scrape",
      "name": "Scrape via Browserless"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Parse Browserless response and filter jobs\nconst response = $input.first().json;\n\nlet jobs = [];\nif (response.data && response.data.jobs) {\n  jobs = response.data.jobs;\n} else if (response.data && Array.isArray(response.data)) {\n  jobs = response.data;\n} else if (Array.isArray(response)) {\n  jobs = response;\n} else if (response.error) {\n  return [{ json: { error: response.error } }];\n}\n\n// Filter for support/success leadership roles\nconst supportKeywords = ['support', 'success', 'customer', 'client', 'cx', 'experience'];\nconst leadershipKeywords = ['manager', 'director', 'vp', 'vice president', 'head', 'lead', 'chief', 'supervisor', 'team lead'];\n\nconst filteredJobs = jobs.filter(job => {\n  if (job.error) return false;\n  const title = (job.title || '').toLowerCase();\n  const hasSupport = supportKeywords.some(kw => title.includes(kw));\n  const hasLeadership = leadershipKeywords.some(kw => title.includes(kw));\n  return hasSupport && hasLeadership;\n});\n\nif (filteredJobs.length === 0) {\n  return [{ json: { _empty: true, _rawCount: jobs.length, _message: 'No jobs matched both support AND leadership keywords' } }];\n}\n\nreturn filteredJobs.map(job => ({\n  json: {\n    \"Job Title\": job.title,\n    \"Company\": job.company,\n    \"Location\": job.location || 'Not specified',\n    \"Source\": 'Work at a Startup',\n    \"Job URL\": job.url,\n    \"Job ID\": job.jobId,\n    \"Salary Info\": job.salary || 'Not specified',\n    \"Date Found\": new Date().toISOString().split('T')[0],\n    \"Review Status\": \"New\",\n    \"_ycBatch\": job.ycBatch || '',\n    \"_scrapedIndustry\": job.industry || ''\n  }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [0, 0],
      "id": "parse-and-filter",
      "name": "Parse & Filter"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json._empty }}",
              "operation": "notEqual",
              "value2": true
            },
            {
              "value1": "={{ $json.error }}",
              "operation": "isEmpty"
            }
          ]
        },
        "combineOperation": "all"
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [200, 0],
      "id": "has-jobs",
      "name": "Has Jobs?"
    },
    {
      "parameters": {
        "authentication": "airtableTokenApi",
        "operation": "append",
        "application": "appFEzXvPWvRtXgRY",
        "table": "tbl6ZV2rHjWz56pP3",
        "addAllFields": false,
        "fields": [
          "Job Title",
          "Company",
          "Location",
          "Source",
          "Job URL",
          "Job ID",
          "Salary Info",
          "Date Found",
          "Review Status",
          "Tide-Pool Score",
          "Tide-Pool Rationale",
          "Industry",
          "Company Stage"
        ],
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 1,
      "position": [600, -100],
      "id": "add-to-airtable",
      "name": "Add to Airtable",
      "credentials": {
        "airtableTokenApi": {
          "id": "sempBDy7tuv1mA6y",
          "name": "Airtable Personal Access Token account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [600, 100],
      "id": "no-jobs",
      "name": "No Jobs/Error"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Rate job fit using Claude AI\nconst PROFILE_URL = 'https://raw.githubusercontent.com/zelman/tidepool/main/tide-pool-agent-lens.md';\n\ntry {\n  const job = $input.item.json;\n  const ycBatch = job['_ycBatch'] || '';\n  const scrapedIndustry = job['_scrapedIndustry'] || '';\n  \n  // Get API key from Airtable Config (n8n Cloud blocks $env access)\n  const apiKey = $('Parse Config').first().json.ANTHROPIC_API_KEY;\n  \n  if (!apiKey) {\n    return { json: { ...job, 'Tide-Pool Score': 0, 'Tide-Pool Rationale': 'ANTHROPIC_API_KEY not found in Airtable Config', 'Industry': scrapedIndustry, 'Company Stage': ycBatch } };\n  }\n  \n  // Fetch the career profile from GitHub\n  const profileContent = await this.helpers.httpRequest({\n    method: 'GET',\n    url: PROFILE_URL,\n    returnFullResponse: false\n  });\n  \n  const prompt = `You are evaluating job fit for a candidate. Here is their profile:\\n\\n${profileContent}\\n\\nCRITICAL SCORING RULES (apply significant penalties):\\n1. COMPANY SIZE: Heavily penalize large/established companies (1000+ employees, 10+ years old, Fortune 500, publicly traded). Target is startups and growth-stage companies (under 500 employees, Series A-C).\\n2. IT CUSTOMER SUCCESS: Heavily penalize roles that are IT-focused, internal IT support, IT service desk, or supporting internal employees rather than external customers. Target is product/external customer success.\\n3. LOCATION: Remote roles are ideal. For on-site/hybrid roles, only these locations are acceptable: Rhode Island (Providence), Massachusetts (Boston area), NYC Metro, LA Metro, SF Bay Area, EU, or UK. Penalize on-site roles in other US locations (e.g., Utah, Texas, midwest).\\n\\nEvaluate this job:\\nTitle: ${job['Job Title']}\\nCompany: ${job['Company']}\\nLocation: ${job['Location']}\\nSalary: ${job['Salary Info']}\\nSource: ${job['Source']}\\nYC Batch: ${ycBatch}\\n\\nRespond with ONLY valid JSON (no markdown, no explanation):\\n{\"score\": <0-100 (large companies and IT roles should score below 30)>, \"rationale\": \"<1-2 sentences, mention if penalized for size or IT focus>\", \"industry\": \"<company industry>\", \"companyStage\": \"<funding stage if known, e.g. Seed, Series A, or empty string>\"}`;\n  \n  const data = await this.helpers.httpRequest({\n    method: 'POST',\n    url: 'https://api.anthropic.com/v1/messages',\n    headers: {\n      'Content-Type': 'application/json',\n      'x-api-key': apiKey,\n      'anthropic-version': '2023-06-01'\n    },\n    body: {\n      model: 'claude-3-haiku-20240307',\n      max_tokens: 300,\n      messages: [{ role: 'user', content: prompt }]\n    },\n    json: true\n  });\n  \n  const responseText = data.content?.[0]?.text || '{}';\n  let parsed;\n  try {\n    parsed = JSON.parse(responseText);\n  } catch (e) {\n    parsed = { score: 50, rationale: 'Could not parse AI response', industry: '', companyStage: '' };\n  }\n  \n  // Use scraped values as fallbacks\n  const finalIndustry = parsed.industry || scrapedIndustry || '';\n  const finalStage = parsed.companyStage || ycBatch || '';\n  \n  // Remove internal fields before sending to Airtable\n  const { _ycBatch, _scrapedIndustry, ...cleanJob } = job;\n  \n  return {\n    json: {\n      ...cleanJob,\n      'Tide-Pool Score': parsed.score || 0,\n      'Tide-Pool Rationale': parsed.rationale || '',\n      'Industry': finalIndustry,\n      'Company Stage': finalStage\n    }\n  };\n} catch (error) {\n  const job = $input.item.json;\n  const ycBatch = job['_ycBatch'] || '';\n  const scrapedIndustry = job['_scrapedIndustry'] || '';\n  const { _ycBatch, _scrapedIndustry, ...cleanJob } = job;\n  return {\n    json: {\n      ...cleanJob,\n      'Tide-Pool Score': 0,\n      'Tide-Pool Rationale': 'Error: ' + error.message,\n      'Industry': scrapedIndustry,\n      'Company Stage': ycBatch\n    }\n  };\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [400, -100],
      "id": "rate-job-fit",
      "name": "Rate Job Fit"
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Get Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Config": {
      "main": [
        [
          {
            "node": "Parse Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Config": {
      "main": [
        [
          {
            "node": "Scrape via Browserless",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Scrape via Browserless": {
      "main": [
        [
          {
            "node": "Parse & Filter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse & Filter": {
      "main": [
        [
          {
            "node": "Has Jobs?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Jobs?": {
      "main": [
        [
          {
            "node": "Rate Job Fit",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Jobs/Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rate Job Fit": {
      "main": [
        [
          {
            "node": "Add to Airtable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "waas-v4",
  "meta": {
    "instanceId": "work-at-a-startup-scraper"
  },
  "id": "waas-scraper",
  "tags": []
}
