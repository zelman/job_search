{
  "name": "Job Alert Email Parser v3-31",
  "nodes": [
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Route based on email sender - reference original email data from Get many messages\nconst emailData = $('Get many messages').item.json;\nlet from = emailData.from || emailData.From || '';\n\n// Handle object format (Gmail returns {value: [{address, name}], text, html})\nif (from && typeof from === 'object') {\n  from = from.text || (from.value && from.value[0] && from.value[0].address) || '';\n}\n\n// If not found, check payload.headers (Gmail API format)\nif (!from && emailData.payload && emailData.payload.headers) {\n  const headers = emailData.payload.headers;\n  const fromHeader = headers.find(h => h.name.toLowerCase() === 'from');\n  if (fromHeader) from = fromHeader.value;\n}\n\nconst fromLower = (from || '').toLowerCase();\n\nlet source = 'Other';\nif (fromLower.includes('indeed')) source = 'Indeed';\nelse if (fromLower.includes('linkedin')) source = 'LinkedIn';\nelse if (fromLower.includes('wellfound')) source = 'Wellfound';\nelse if (fromLower.includes('builtin') || fromLower.includes('built-in') || fromLower.includes('built in')) source = 'Built In';\nelse if (fromLower.includes('remotive')) source = 'Remotive';\nelse if (fromLower.includes('himalayas')) source = 'Himalayas';\nelse if (fromLower.includes('welcometothejungle')) source = 'Welcome to the Jungle';\nelse if (fromLower.includes('jobright')) source = 'Jobright';\nelse if (fromLower.includes('careers-noreply@google.com') || fromLower.includes('google.com/about/careers')) source = 'Google Careers';\nelse if (fromLower.includes('bloomberry')) source = 'Bloomberry';\nelse if (fromLower.includes('underdog.io') || fromLower.includes('conversations.underdog')) source = 'Underdog';\n\nreturn { json: { ...emailData, _source: source } };"
      },
      "id": "96aae314-91a9-4399-833b-95f3852bd51d",
      "name": "Identify Source",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4624, 1184]
    },
    {
      "parameters": {
        "jsCode": "// Parse Jobs - Multi-source parser v9 (Run Once for All Items mode)\n// Process all emails and collect all jobs into one output array\n\nconst allEmails = $input.all();\nconst allJobs = [];\n\n// Helper function to decode base64url (Gmail API format)\nconst decodeBase64Url = (data) => {\n  if (!data) return '';\n  if (/\\s{2,}/.test(data) && /[a-z]{4,}\\s+[a-z]{4,}/i.test(data)) return data;\n  const sample = data.substring(0, 100);\n  if (!/\\s/.test(sample) && /^[A-Za-z0-9_-]+=*$/.test(sample.replace(/\\s/g, ''))) {\n    try {\n      const cleaned = data.replace(/\\s/g, '');\n      const base64 = cleaned.replace(/-/g, '+').replace(/_/g, '/');\n      const decoded = Buffer.from(base64, 'base64').toString('utf-8');\n      if (/[a-z]{3,}/i.test(decoded) && !/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/.test(decoded)) return decoded;\n    } catch (e) {}\n  }\n  return data;\n};\n\n// Helper to strip HTML tags\nconst stripHtml = (html) => {\n  if (!html) return '';\n  return html\n    .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')\n    .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')\n    .replace(/<[^>]+>/g, ' ')\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&#39;/g, \"'\")\n    .replace(/&quot;/g, '\"')\n    .replace(/\\s+/g, ' ')\n    .trim();\n};\n\n// Helper to recursively find text content in MIME parts\nconst extractTextFromParts = (parts) => {\n  if (!parts || !Array.isArray(parts)) return '';\n\n  for (const part of parts) {\n    const mimeType = part.mimeType || '';\n\n    if (mimeType === 'text/plain' && part.body && part.body.data) {\n      return decodeBase64Url(part.body.data);\n    }\n\n    if (mimeType.startsWith('multipart/') && part.parts) {\n      const nested = extractTextFromParts(part.parts);\n      if (nested) return nested;\n    }\n  }\n\n  // Fallback to text/html\n  for (const part of parts) {\n    if (part.mimeType === 'text/html' && part.body && part.body.data) {\n      const html = decodeBase64Url(part.body.data);\n      return stripHtml(html);\n    }\n    if (part.parts) {\n      const nested = extractTextFromParts(part.parts);\n      if (nested) return nested;\n    }\n  }\n\n  return '';\n};\n\n// Helper to extract raw HTML from email (for URL extraction)\nconst extractHtmlFromParts = (parts) => {\n  if (!parts || !Array.isArray(parts)) return '';\n\n  for (const part of parts) {\n    if (part.mimeType === 'text/html' && part.body && part.body.data) {\n      return decodeBase64Url(part.body.data);\n    }\n    if (part.parts) {\n      const nested = extractHtmlFromParts(part.parts);\n      if (nested) return nested;\n    }\n  }\n  return '';\n};\n\n// Process each email\nfor (const emailItem of allEmails) {\n  const email = emailItem.json;\n  const source = email._source || 'Other';\n  \n  // Try multiple possible locations for email body content\n  let textContent = '';\n  let htmlContent = '';\n\n  // 1. Check common field names first (n8n Gmail node simplified output)\n  if (email.textPlain) textContent = email.textPlain;\n  if (email.textHtml) htmlContent = email.textHtml;\n  else if (email.html) htmlContent = email.html;\n  if (email.text) textContent = email.text;\n\n  // 2. Check Gmail-specific structure: payload\n  if (email.payload) {\n    const payload = email.payload;\n    if (payload.mimeType === 'text/html' && payload.body && payload.body.data) {\n      htmlContent = decodeBase64Url(payload.body.data);\n      if (!textContent) textContent = stripHtml(htmlContent);\n    }\n    else if (payload.parts && payload.parts.length > 0) {\n      if (!htmlContent) htmlContent = extractHtmlFromParts(payload.parts);\n      if (!textContent) textContent = extractTextFromParts(payload.parts);\n    }\n    else if (payload.body && payload.body.data) {\n      if (!textContent) textContent = decodeBase64Url(payload.body.data);\n    }\n  }\n\n  // 3. Fallback to snippet\n  if (!textContent && email.snippet) textContent = email.snippet;\n\n  // 4. Final fallback: convert HTML to text if still no text content\n  if (!textContent && htmlContent) textContent = stripHtml(htmlContent);\n\n  const jobs = [];\n  let parserError = null;\n\n// === SOURCE-SPECIFIC PARSERS ===\n\ntry {\n\nif (source === 'LinkedIn') {\n  const sections = textContent.split(/[-]{10,}/);\n\n  for (const section of sections) {\n    const urlMatch = section.match(/linkedin\\.com\\/(?:comm\\/)?jobs\\/view\\/(\\d+)/);\n    if (!urlMatch) continue;\n\n    const jobId = urlMatch[1];\n    const jobUrl = `https://www.linkedin.com/jobs/view/${jobId}`;\n\n    const textBefore = section.split(/View job/i)[0].trim();\n\n    const parts = textBefore\n      .replace(/https?:\\/\\/[^\\s]+/g, '')\n      .split(/\\n/)\n      .map(p => p.replace(/\\s+/g, ' ').trim())\n      .filter(p => p.length > 1);\n\n    const noise = ['high skills match', 'fast growing', 'actively hiring', 'connections', 'posted', 'applicants', 'promoted', 'apply with resume', 'this company is', 'school alum', 'connection', 'top job picks', 'your job alert', 'new jobs match your preferences', 'match your preferences'];\n    const cleanParts = parts.filter(p => !noise.some(n => p.toLowerCase().includes(n)));\n\n    if (cleanParts.length >= 2) {\n      jobs.push({\n        title: cleanParts[0],\n        company: cleanParts[1],\n        location: cleanParts[2] || 'United States',\n        salary: 'Not specified',\n        source: 'LinkedIn',\n        url: jobUrl,\n        jobId: `linkedin-${jobId}`\n      });\n    }\n  }\n}\n\nelse if (source === 'Himalayas') {\n  const seenJobs = new Set();\n\n  let decodedContent = textContent;\n  try {\n    decodedContent = decodeURIComponent(decodeURIComponent(textContent));\n  } catch (e) {\n    try {\n      decodedContent = decodeURIComponent(textContent);\n    } catch (e2) {}\n  }\n\n  const urlPattern = /himalayas\\.app\\/companies\\/([^\\/]+)\\/jobs\\/([^\\s\\/\\]\"&<>]+)/gi;\n  let urlMatch;\n\n  while ((urlMatch = urlPattern.exec(decodedContent)) !== null) {\n    const companySlug = urlMatch[1];\n    const titleSlug = urlMatch[2];\n\n    const company = companySlug\n      .split('-')\n      .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n      .join(' ');\n\n    const title = titleSlug\n      .replace(/-\\d+$/, '')\n      .split('-')\n      .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n      .join(' ');\n\n    if (title.length < 3 || company.length < 2) continue;\n\n    const key = `${title.toLowerCase()}-${company.toLowerCase()}`;\n    if (seenJobs.has(key)) continue;\n    seenJobs.add(key);\n\n    jobs.push({\n      title: title,\n      company: company,\n      location: 'Remote',\n      salary: 'Not specified',\n      source: 'Himalayas',\n      url: `https://himalayas.app/companies/${companySlug}/jobs/${titleSlug}`,\n      jobId: `himalayas-${Date.now()}-${jobs.length}`\n    });\n  }\n}\n\nelse if (source === 'Wellfound') {\n  const urlMatches = [...textContent.matchAll(/wellfound\\.com\\/jobs\\?job_listing_slug=(\\d+[^\\s>\"'\\]]*)/gi)];\n  const jobSlugs = urlMatches.map(m => m[1]);\n\n  const jobPattern = /([A-Za-z][A-Za-z\\s&\\-,\\(\\)]+?(?:Manager|Director|Specialist|Associate|Coordinator|Analyst|Engineer|Representative|Support|Success)(?:[A-Za-z\\s&\\-,\\(\\)]*?))\\s+([A-Z][A-Za-z0-9\\s&\\.\\-']+?)\\s*\\/\\s*(\\d+[-–]\\d+|\\d+\\+?)\\s*Employees/gi;\n\n  let match;\n  let index = 0;\n  while ((match = jobPattern.exec(textContent)) !== null) {\n    const title = match[1].trim();\n    const company = match[2].trim();\n    const size = match[3];\n\n    const afterMatch = textContent.substring(match.index + match[0].length, match.index + match[0].length + 100);\n    const locationMatch = afterMatch.match(/\\|\\s*([^|]+?)(?:\\s*\\||$)/);\n    const location = locationMatch ? locationMatch[1].trim() : 'Remote';\n\n    jobs.push({\n      title: title,\n      company: company,\n      location: location,\n      salary: 'Not specified',\n      source: 'Wellfound',\n      url: jobSlugs[index] ? `https://wellfound.com/jobs?job_listing_slug=${jobSlugs[index]}` : 'https://wellfound.com',\n      jobId: jobSlugs[index] ? `wellfound-${jobSlugs[index].split('-')[0]}` : `wellfound-${Date.now()}-${index}`,\n      _companySize: `${size} Employees`\n    });\n    index++;\n  }\n}\n\nelse if (source === 'Built In') {\n  const builtInUrls = [];\n  const searchContent = htmlContent || textContent;\n  const urlPattern = /https?:\\/\\/(?:www\\.)?builtin\\.com\\/job\\/[^\\s\"'<>]+/gi;\n  let urlMatch;\n  while ((urlMatch = urlPattern.exec(searchContent)) !== null) {\n    builtInUrls.push(urlMatch[0].replace(/&amp;/g, '&'));\n  }\n  const trackingPattern = /href=[\"']([^\"']*builtin[^\"']*job[^\"']*)[\"']/gi;\n  while ((urlMatch = trackingPattern.exec(searchContent)) !== null) {\n    const url = urlMatch[1].replace(/&amp;/g, '&');\n    if (!builtInUrls.includes(url)) builtInUrls.push(url);\n  }\n  \n  let jobIndex = 0;\n  \n  const sectionMatch = textContent.match(/(?:Senior Level|Expert Level|Entry Level|Mid Level)\\s+([\\s\\S]*?)(?:Get More|©|Built In,)/i);\n  if (sectionMatch) {\n    const jobSection = sectionMatch[1].trim();\n    \n    const salaryPattern = /\\$[\\d,]+(?:\\s*-\\s*\\$?[\\d,]+)?/g;\n    const salaries = [];\n    let salaryMatch;\n    while ((salaryMatch = salaryPattern.exec(jobSection)) !== null) {\n      salaries.push({ text: salaryMatch[0], index: salaryMatch.index });\n    }\n    \n    for (let i = 0; i < salaries.length; i++) {\n      const startIdx = i === 0 ? 0 : salaries[i-1].index + salaries[i-1].text.length;\n      const endIdx = salaries[i].index;\n      const jobText = jobSection.substring(startIdx, endIdx).trim();\n      const salary = salaries[i].text;\n      \n      if (jobText.length < 10) continue;\n      \n      const locationPattern = /((?:Remote(?:\\s+[A-Za-z]+)*|[A-Z][a-z]+(?:,\\s*[A-Z]{2})?))\\s*$/;\n      const locMatch = jobText.match(locationPattern);\n      const location = locMatch ? locMatch[1].trim() : 'Not specified';\n      const textWithoutLocation = locMatch ? jobText.substring(0, locMatch.index).trim() : jobText;\n      \n      const titlePattern = /((?:Sr\\.?|Jr\\.?|Senior|Junior|Lead|Staff|Principal|Associate|Manager|Director|VP|Head|Chief|Engineer|Specialist|Coordinator|Representative|Analyst|Consultant|Support|Customer|Digital|Technical)[\\s\\S]*?)$/i;\n      const titleMatch = textWithoutLocation.match(titlePattern);\n      \n      let title = '';\n      let company = '';\n      \n      if (titleMatch) {\n        title = titleMatch[1].trim();\n        company = textWithoutLocation.substring(0, titleMatch.index).trim();\n      } else {\n        const words = textWithoutLocation.split(/\\s+/);\n        if (words.length >= 3) {\n          company = words.slice(0, 2).join(' ');\n          title = words.slice(2).join(' ');\n        }\n      }\n      \n      if (title && company && title.length > 3) {\n        jobs.push({\n          title: title,\n          company: company,\n          location: location,\n          salary: salary,\n          source: 'Built In',\n          url: builtInUrls[jobIndex] || 'https://builtin.com/jobs',\n          jobId: `builtin-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n        });\n        jobIndex++;\n      }\n    }\n  }\n  \n  if (jobs.length === 0) {\n    const atPattern = /([A-Za-z\\s,\\/&]+(?:Support|Success|Director|Manager|Head|VP|Lead|Engineer|Representative|Specialist)[A-Za-z\\s,\\/&]*)\\s+at\\s+([A-Za-z0-9\\s&.,'\\\\-]+?)(?:\\s+in\\s+([A-Za-z\\s,]+?))?(?:\\n|$)/gi;\n    let match;\n    let fallbackIdx = 0;\n    while ((match = atPattern.exec(textContent)) !== null) {\n      jobs.push({\n        title: match[1].trim(),\n        company: match[2].trim(),\n        location: match[3] ? match[3].trim() : 'Not specified',\n        salary: 'Not specified',\n        source: 'Built In',\n        url: builtInUrls[fallbackIdx] || 'https://builtin.com/jobs',\n        jobId: `builtin-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n      });\n      fallbackIdx++;\n    }\n  }\n}\n\nelse if (source === 'Remotive') {\n  let searchContent = htmlContent || textContent;\n\n  searchContent = searchContent\n    .replace(/=\\r?\\n/g, '')\n    .replace(/=([0-9A-Fa-f]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));\n\n  const liPattern = /<li[^>]*>([\\s\\S]*?)<\\/li>/gi;\n  let liMatch;\n\n  while ((liMatch = liPattern.exec(searchContent)) !== null) {\n    const liContent = liMatch[1];\n\n    const urlMatch = liContent.match(/href=[\"']https?:\\/\\/track\\.pstmrk\\.it\\/3s\\/([^\\/]+(?:%2F[^\\/]+)*)\\/eHy2/i);\n    if (!urlMatch) continue;\n\n    const encodedUrl = urlMatch[1];\n\n    let jobUrl;\n    try {\n      jobUrl = 'https://' + decodeURIComponent(encodedUrl);\n    } catch (e) {\n      jobUrl = 'https://' + encodedUrl.replace(/%2F/gi, '/').replace(/%3A/gi, ':');\n    }\n\n    if (jobUrl.includes('remotive.com') && !jobUrl.includes('remote-jobs/')) continue;\n    if (jobUrl.includes('linkedin.com/company')) continue;\n    if (jobUrl.includes('twitter.com')) continue;\n    if (jobUrl.includes('unsubscribe')) continue;\n\n    const titleMatch = liContent.match(/<span[^>]*font-weight:\\s*bold[^>]*>([^<]+)<\\/span>/i);\n    const title = titleMatch ? titleMatch[1].trim() : '';\n\n    const companyMatch = liContent.match(/at\\s*<span[^>]*>([^<]+)<\\/span>/i);\n    const company = companyMatch ? companyMatch[1].trim() : '';\n\n    const locationMatch = liContent.match(/(?:&#x1F4CD;|\\u{1F4CD})\\s*([A-Za-z\\s,]+)/iu);\n    const location = locationMatch ? locationMatch[1].trim() : 'Remote';\n\n    if (title && company) {\n      jobs.push({\n        title: title,\n        company: company,\n        location: location,\n        salary: 'Not specified',\n        source: 'Remotive',\n        url: jobUrl,\n        jobId: `remotive-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n      });\n    }\n  }\n\n  if (jobs.length === 0) {\n    const textPattern = /([A-Za-z][A-Za-z\\s,\\/&\\-]+?(?:Manager|Director|Head|VP|Lead|Engineer|Specialist|Coordinator|Analyst|Representative|Support|Success)[A-Za-z\\s,\\/&]*)\\s+at\\s+([A-Za-z0-9][A-Za-z0-9\\s&.,'\\\\-]+?)(?:\\s*\\u{1F4CD}\\s*([A-Za-z\\s,]+))?(?:\\s|$|Looking)/giu;\n\n    let match;\n    while ((match = textPattern.exec(textContent)) !== null) {\n      jobs.push({\n        title: match[1].trim(),\n        company: match[2].trim(),\n        location: match[3] ? match[3].trim() : 'Remote',\n        salary: 'Not specified',\n        source: 'Remotive',\n        url: 'https://remotive.com/remote-jobs',\n        jobId: `remotive-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n      });\n    }\n  }\n}\n\nelse if (source === 'Indeed') {\n  const indeedUrls = [];\n  const searchContent = htmlContent || textContent;\n\n  const indeedUrlPattern = /https?:\\/\\/(?:[a-z]+\\.)?indeed\\.com\\/(?:viewjob\\?|rc\\/clk\\?|jobs\\?|job\\/)[^\\s\"'<>]+/gi;\n  let urlMatch;\n  while ((urlMatch = indeedUrlPattern.exec(searchContent)) !== null) {\n    indeedUrls.push(urlMatch[0].replace(/&amp;/g, '&'));\n  }\n\n  const trackingPattern = /to\\.indeed\\.com\\/[a-zA-Z0-9]+/gi;\n  while ((urlMatch = trackingPattern.exec(searchContent)) !== null) {\n    indeedUrls.push(`https://${urlMatch[0]}`);\n  }\n\n  const jobPattern = /([A-Za-z\\s,\\/&]+(?:Support|Success|Director|Manager|Head|VP|Lead|Engineer|Representative|Specialist)[A-Za-z\\s,\\/&]*)\\s+at\\s+([A-Za-z0-9\\s&.,'\\\\-]+?)(?:\\s*[-–]\\s*|\\s*\\n|\\s*$)/gi;\n\n  let match;\n  let jobIndex = 0;\n  while ((match = jobPattern.exec(textContent)) !== null) {\n    const salaryMatch = textContent.substring(match.index, match.index + 200).match(/\\$[\\d,]+(?:\\s*[-–]\\s*\\$[\\d,]+)?(?:\\s*(?:\\/|per|a)\\s*(?:year|yr|hour|hr|month))?/i);\n\n    jobs.push({\n      title: match[1].trim(),\n      company: match[2].trim(),\n      location: 'Not specified',\n      salary: salaryMatch ? salaryMatch[0].trim() : 'Not specified',\n      source: 'Indeed',\n      url: indeedUrls[jobIndex] || 'https://indeed.com',\n      jobId: `indeed-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n    });\n    jobIndex++;\n  }\n}\n\nelse if (source === 'Welcome to the Jungle') {\n  let searchContent = htmlContent || textContent;\n  \n  searchContent = searchContent\n    .replace(/=\\r?\\n/g, '')\n    .replace(/=3D/g, '=')\n    .replace(/=([0-9A-Fa-f]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));\n  \n  const jobBlocks = [];\n  const blockPattern = /<a[^>]*href=[\"']?(https:\\/\\/[^\"'\\s]*(?:sendgrid\\.net|ct\\.sendgrid\\.net)\\/ls\\/click[^\"'\\s]*)[\"']?[^>]*>[\\s\\S]*?<\\/a>/gi;\n  \n  let blockMatch;\n  while ((blockMatch = blockPattern.exec(searchContent)) !== null) {\n    const url = blockMatch[1];\n    const content = blockMatch[0];\n    \n    if (content.includes('Jungle logo') || content.includes('unsubscribe') || content.includes('manage your')) continue;\n    if (!content.includes('Salary:')) continue;\n    \n    jobBlocks.push({ url, content });\n  }\n  \n  const seenJobs = new Set();\n  \n  for (const block of jobBlocks) {\n    const strongMatches = [...block.content.matchAll(/<strong>([^<]+)<\\/strong>/gi)];\n    let company = '';\n    let title = '';\n    \n    for (const sm of strongMatches) {\n      const text = sm[1].trim();\n      if (!text || text.length < 2) continue;\n      if (text.toLowerCase().includes('jungle')) continue;\n      \n      if (!company) {\n        company = text;\n      } else if (!title) {\n        title = text;\n        break;\n      }\n    }\n    \n    const salaryMatch = block.content.match(/Salary:\\s*(\\$[\\d,]+(?:\\s*[-–]\\s*\\$?[\\d,]+)?K?)/i);\n    const salary = salaryMatch ? salaryMatch[1].trim() : 'Not specified';\n    \n    const locationMatch = block.content.match(/(?:Remote|Hybrid|On-?site)[^<]*(?:\\([^)]+\\))?/i);\n    const location = locationMatch ? locationMatch[0].trim() : 'Not specified';\n    \n    if (title && company) {\n      const key = `${title.toLowerCase()}-${company.toLowerCase()}`;\n      if (seenJobs.has(key)) continue;\n      seenJobs.add(key);\n      \n      jobs.push({\n        title: title,\n        company: company,\n        location: location,\n        salary: salary,\n        source: 'Welcome to the Jungle',\n        url: block.url,\n        jobId: `wttj-${Date.now()}-${jobs.length}`\n      });\n    }\n  }\n}\n\nelse if (source === 'Google Careers') {\n  let searchContent = htmlContent || textContent;\n  searchContent = searchContent\n    .replace(/=\\r?\\n/g, '')\n    .replace(/=3D/g, '=')\n    .replace(/=([0-9A-Fa-f]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));\n  \n  const jobPattern = /href=([\"']?)https:\\/\\/www\\.google\\.com\\/about\\/careers\\/applications\\/jobs\\/results\\/(\\d+)-([^?\\s\"']+)[^>]*>[\\s\\S]*?<u>([^<]+)<\\/u>[\\s\\S]*?Google[\\s&;nbsp;]*[–-][\\s&;nbsp;]*([^<]+?)(?:<br|<\\/span)/gi;\n  \n  let match;\n  const seenIds = new Set();\n  \n  while ((match = jobPattern.exec(searchContent)) !== null) {\n    const jobId = match[2];\n    if (seenIds.has(jobId)) continue;\n    seenIds.add(jobId);\n    \n    const slug = match[3];\n    const title = match[4].trim();\n    let location = match[5].trim()\n      .replace(/&nbsp;/g, ' ')\n      .replace(/&ndash;/g, '-')\n      .replace(/<[^>]+>/g, '')\n      .trim();\n    \n    if (location.toLowerCase().includes('yesterday') || location.toLowerCase().includes('days ago')) {\n      location = location.replace(/yesterday|\\d+ days? ago/gi, '').trim();\n    }\n    if (!location || location.length < 2) location = 'Multiple Sites';\n    \n    const url = `https://www.google.com/about/careers/applications/jobs/results/${jobId}-${slug}`;\n    \n    if (title) {\n      jobs.push({\n        title: title,\n        company: 'Google',\n        location: location,\n        salary: 'Not specified',\n        source: 'Google Careers',\n        url: url,\n        jobId: `google-${jobId}`\n      });\n    }\n  }\n}\n\nelse if (source === 'Jobright') {\n  let searchContent = htmlContent || textContent;\n  searchContent = searchContent\n    .replace(/=\\r?\\n/g, '')\n    .replace(/=3D/g, '=')\n    .replace(/=([0-9A-Fa-f]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));\n  \n  const isSalaryTag = (tag) => /\\$\\d|\\d+K\\/yr/i.test(tag);\n  const isIgnoredTag = (tag) => /referral|applicant|posted|ago|alumni|early applicant/i.test(tag);\n  \n  const seenUrls = new Set();\n  \n  const tablePattern = /<table[^>]*border-radius:\\s*16px[^>]*>[\\s\\S]*?<\\/table>/gi;\n  const jobTables = searchContent.match(tablePattern) || [];\n  \n  for (const table of jobTables) {\n    if (!table.includes('APPLY NOW') && !table.includes('jobright.ai/jobs/info')) continue;\n    \n    const urlMatch = table.match(/href=[\"\\']?(https:\\/\\/jobright\\.ai\\/jobs\\/info\\/[a-f0-9]+)/i);\n    if (!urlMatch) continue;\n    const url = urlMatch[1].trim();\n    if (seenUrls.has(url)) continue;\n    seenUrls.add(url);\n    \n    const titleMatch = table.match(/font-size:\\s*16px;\\s*font-weight:\\s*640[^>]*>\\s*([^<]+)/i);\n    const title = titleMatch ? titleMatch[1].trim() : '';\n    \n    const companyMatch = table.match(/font-size:\\s*13px;\\s*font-weight:\\s*500[^>]*>\\s*([^<]+)/i);\n    const company = companyMatch ? companyMatch[1].trim() : '';\n    \n    const tagPattern = /background:\\s*#f2f4f5[^>]*>\\s*([^<]+)/gi;\n    const tags = [];\n    let tagMatch;\n    while ((tagMatch = tagPattern.exec(table)) !== null) {\n      tags.push(tagMatch[1].trim());\n    }\n    \n    let salary = 'Not specified';\n    let location = 'Not specified';\n    \n    for (const tag of tags) {\n      if (isSalaryTag(tag)) {\n        salary = tag;\n      } else if (tag.length > 0 && !isIgnoredTag(tag)) {\n        location = tag;\n      }\n    }\n    \n    if (title && company) {\n      jobs.push({\n        title: title,\n        company: company,\n        location: location,\n        salary: salary,\n        source: 'Jobright',\n        url: url,\n        jobId: `jobright-${url.split('/').pop()}`\n      });\n    }\n  }\n}\n\nelse if (source === 'Bloomberry') {\n  let searchContent = htmlContent || textContent;\n  \n  searchContent = searchContent\n    .replace(/=\\r?\\n/g, '')\n    .replace(/=3D/g, '=')\n    .replace(/=([0-9A-Fa-f]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));\n  \n  const jobPattern = /\\d+\\)\\s*<b><a\\s+href=[\"']?([^\"'>}]+)[}\"']*[^>]*>([^<]*)<\\/a><\\/b>\\s*\\(([^)]+)\\),\\s*([^<]+?)(?:\\s+-\\s+<i>\\s*([^<]+)<\\/i>|(?=<br|$))/gi;\n  \n  let match;\n  const seenJobs = new Set();\n  \n  while ((match = jobPattern.exec(searchContent)) !== null) {\n    const url = match[1].trim();\n    let title = match[2].trim();\n    const location = match[3].trim();\n    const company = match[4].trim();\n    const salary = match[5] ? match[5].trim() : 'Not specified';\n    \n    if (!title || title.length < 3) continue;\n    if (url.includes('unsubscribe') || url.includes('bloomberry.com/blog')) continue;\n    \n    const key = `${title.toLowerCase()}-${company.toLowerCase()}`;\n    if (seenJobs.has(key)) continue;\n    seenJobs.add(key);\n    \n    jobs.push({\n      title: title,\n      company: company,\n      location: location,\n      salary: salary,\n      source: 'Bloomberry',\n      url: url,\n      jobId: `bloomberry-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n    });\n  }\n}\n\nelse if (source === 'Underdog') {\n  // Underdog.io - reverse recruiting platform where companies reach out to candidates\n  let searchContent = htmlContent || textContent;\n  \n  // Extract company name - usually prominent in the email\n  const companyPatterns = [\n    /([A-Z][A-Za-z0-9\\s&.\\-']+?)\\s+(?:is interested|wants to connect|would like to|reached out|sent you)/i,\n    /from\\s+([A-Z][A-Za-z0-9\\s&.\\-']+?)\\s+(?:on Underdog|via Underdog)/i,\n    /([A-Z][A-Za-z0-9\\s&.\\-']+?)\\s+on Underdog\\.io/i,\n    /New message from\\s+([A-Z][A-Za-z0-9\\s&.\\-']+)/i\n  ];\n  \n  let company = '';\n  for (const pattern of companyPatterns) {\n    const match = searchContent.match(pattern);\n    if (match && match[1] && match[1].length >= 2 && match[1].length <= 50) {\n      company = match[1].trim();\n      break;\n    }\n  }\n  \n  // Try to extract role/position if mentioned\n  const rolePatterns = [\n    /(?:for|about|regarding|re:?)\\s+(?:the\\s+)?([A-Za-z\\s]+(?:Manager|Director|Head|VP|Lead|Chief|Officer)[A-Za-z\\s]*?)\\s+(?:role|position|opportunity)/i,\n    /([A-Za-z\\s]+(?:Manager|Director|Head|VP|Lead|Chief|Officer)[A-Za-z\\s]*?)\\s+(?:role|position)/i\n  ];\n  \n  let title = 'Company Interest via Underdog';\n  for (const pattern of rolePatterns) {\n    const match = searchContent.match(pattern);\n    if (match && match[1]) {\n      title = match[1].trim();\n      break;\n    }\n  }\n  \n  // Extract Underdog URL\n  const urlMatch = searchContent.match(/https?:\\/\\/(?:app\\.)?underdog\\.io\\/[^\\s\"'<>]+/i);\n  const url = urlMatch ? urlMatch[0] : 'https://underdog.io/candidates/dashboard';\n  \n  if (company) {\n    jobs.push({\n      title: title,\n      company: company,\n      location: 'Not specified',\n      salary: 'Not specified',\n      source: 'Underdog',\n      url: url,\n      jobId: `underdog-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n    });\n  } else {\n    // Fallback: extract any company-like names\n    const fallbackMatch = textContent.match(/\\b([A-Z][A-Za-z0-9]+(?:\\s+[A-Z][A-Za-z0-9]+)?)\\b.*?(?:team|company|startup)/i);\n    if (fallbackMatch) {\n      jobs.push({\n        title: 'Company Interest via Underdog',\n        company: fallbackMatch[1].trim(),\n        location: 'Not specified',\n        salary: 'Not specified',\n        source: 'Underdog',\n        url: url,\n        jobId: `underdog-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n      });\n    }\n  }\n}\n\nelse {\n  const atPattern = /([A-Za-z\\s,\\/&]+(?:Support|Success|Director|Manager|Head|VP|Lead|Engineer)[A-Za-z\\s,\\/&]*)\\s+at\\s+([A-Za-z0-9\\s&.,'\\\\-]+)/gi;\n  let match;\n  while ((match = atPattern.exec(textContent)) !== null) {\n    jobs.push({\n      title: match[1].trim(),\n      company: match[2].trim(),\n      location: 'Not specified',\n      salary: 'Not specified',\n      source: source,\n      url: '',\n      jobId: `other-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n    });\n  }\n}\n\n} catch (e) {\n  parserError = { source: source, error: e.message };\n}\n\n  const seen = new Set();\n  const uniqueJobs = jobs.filter(job => {\n    const key = `${job.title.toLowerCase()}-${job.company.toLowerCase()}`;\n    if (seen.has(key)) return false;\n    seen.add(key);\n    return true;\n  });\n\n  const emailId = email.id || '';\n  if (uniqueJobs.length === 0) {\n    allJobs.push({ _noJobs: true, _source: source, _rawText: (textContent || '').substring(0, 500), _emailId: emailId, _parserError: parserError });\n  } else {\n    for (const job of uniqueJobs) {\n      allJobs.push({\n        title: job.title,\n        company: job.company,\n        location: job.location,\n        salary: job.salary,\n        source: job.source,\n        url: job.url,\n        jobId: job.jobId,\n        _dateFound: new Date().toISOString().split('T')[0],\n        _emailId: emailId\n      });\n    }\n  }\n}\n\nif (allJobs.length === 0) {\n  return [{ json: { _noJobs: true, _source: 'None' } }];\n}\n\nreturn allJobs.map(job => ({ json: job }));"
      },
      "id": "78c7cc04-49ae-402e-afd9-de4a73a6175a",
      "name": "Parse Jobs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4848, 1184]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json._noJobs }}",
              "operation": "notEqual",
              "value2": true
            }
          ]
        }
      },
      "id": "7a4ca177-518f-4fa0-a615-2ce0a3894b17",
      "name": "Has Jobs",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [5072, 1184],
      "executeOnce": false
    },
    {
      "parameters": {
        "authentication": "airtableTokenApi",
        "operation": "append",
        "application": "appFEzXvPWvRtXgRY",
        "table": "tbl6ZV2rHjWz56pP3",
        "addAllFields": false,
        "fields": [
          "Job Title",
          "Company",
          "Location",
          "Source",
          "Job URL",
          "Job ID",
          "Salary Info",
          "Date Found",
          "Review Status",
          "Tide-Pool Score",
          "Tide-Pool Rationale",
          "Company Stage",
          "Industry",
          "Role Type",
          "Builder Evidence",
          "Maintainer Evidence",
          "Recommendation"
        ],
        "options": {}
      },
      "id": "a6aa583e-a5c7-4e77-b719-0d97a1860f9e",
      "name": "Add to Airtable",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 1,
      "position": [6864, 1088]
    },
    {
      "parameters": {},
      "id": "f9279dc9-9cb3-4851-9944-862762490190",
      "name": "No Jobs Found",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [5280, 1280]
    },
    {
      "parameters": {
        "jsCode": "// Transform field names to match Airtable exactly\n// Filter to only customer support/success leadership roles\n\nconst items = $input.all().filter(item => !item.json._empty);\n\nif (items.length === 0) {\n  return [{ json: { _empty: true } }];\n}\n\n// Role filter: must contain support/success keywords AND leadership keywords\nconst supportKeywords = ['support', 'success', 'customer', 'client', 'cx', 'experience'];\nconst leadershipKeywords = ['manager', 'director', 'vp', 'vice president', 'head', 'lead', 'chief', 'supervisor', 'team lead'];\n\nconst filteredItems = items.filter(item => {\n  const title = (item.json.title || '').toLowerCase();\n  \n  // Check if title contains any support/success keyword\n  const hasSupport = supportKeywords.some(kw => title.includes(kw));\n  \n  // Check if title contains any leadership keyword\n  const hasLeadership = leadershipKeywords.some(kw => title.includes(kw));\n  \n  return hasSupport && hasLeadership;\n});\n\nif (filteredItems.length === 0) {\n  return [{ json: { _empty: true } }];\n}\n\nreturn filteredItems.map(item => ({\n  json: {\n    \"Job Title\": item.json.title,\n    \"Company\": item.json.company,\n    \"Location\": item.json.location,\n    \"Source\": item.json.source,\n    \"Job URL\": item.json.url,\n    \"Job ID\": item.json.jobId,\n    \"Salary Info\": item.json.salary,\n    \"Date Found\": item.json._dateFound,\n    \"Review Status\": \"New\",\n    \"_emailId\": item.json._emailId\n  }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5504, 1088],
      "id": "830d5e57-d8bf-40bf-8b30-908dd734e78c",
      "name": "Map Fields for Airtable"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [5280, 1088],
      "id": "6c229c04-2e3f-459f-8647-d0f357294057",
      "name": "Merge Inputs"
    },
    {
      "parameters": {
        "operation": "getAll",
        "limit": 5,
        "simple": false,
        "filters": {
          "q": "is:unread in:inbox from:(jobs-listings@linkedin.com OR jobalerts-noreply@linkedin.com OR jobs-noreply@linkedin.com OR builtin.com OR wellfound.com OR himalayas.app OR remotive.com OR welcometothejungle.com OR jobright.ai OR careers-noreply@google.com OR bloomberry.com OR conversations.underdog.io) newer_than:21d"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [4400, 1184],
      "id": "fd8f66e9-72a7-4af1-b6ae-221331871c68",
      "name": "Get many messages",
      "webhookId": "46595c63-cee2-41ff-834e-8114edf3d651"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.3,
      "position": [4192, 1184],
      "id": "440e49ac-d3d0-405c-b5f8-a8d99a56e9a3",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "operation": "addLabels",
        "messageId": "={{ $('Build Prompt').item.json._emailId }}",
        "labelIds": ["Label_3146569228785124450"]
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [7088, 1088],
      "id": "3355ac17-6ec6-4cb7-a0d2-00eed8576f9e",
      "name": "Add label to message",
      "webhookId": "a29818cc-9d22-40cb-ad01-47c3f481b26c"
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "value": "appFEzXvPWvRtXgRY",
          "mode": "list",
          "cachedResultName": "Job search",
          "cachedResultUrl": "https://airtable.com/appFEzXvPWvRtXgRY"
        },
        "table": {
          "__rl": true,
          "value": "tbl6ZV2rHjWz56pP3",
          "mode": "list",
          "cachedResultName": "Job Listings",
          "cachedResultUrl": "https://airtable.com/appFEzXvPWvRtXgRY/tbl6ZV2rHjWz56pP3"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [4848, 1392],
      "id": "68e120ec-e4ed-4962-a4d4-0e6c6f5581e9",
      "name": "Search records"
    },
    {
      "parameters": {
        "jsCode": "// Dedup Code v2 - More aggressive normalization\n\nconst normalize = (str) => {\n  if (!str) return '';\n  return str\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s]/g, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\n};\n\nconst allItems = $input.all();\n\nconst newJobs = allItems.filter(item => \n  item.json.title && item.json.source && !item.json.fields && !item.json[\"Job Title\"]\n);\n\nconst existingRecords = allItems.filter(item => \n  item.json.fields || item.json[\"Job Title\"] || (item.json[\"Job URL\"] && !item.json.source)\n);\n\nconst existingUrls = new Set();\nconst existingKeys = new Set();\n\nfor (const item of existingRecords) {\n  const fields = item.json.fields || item.json;\n  \n  let url = fields[\"Job URL\"] || \"\";\n  if (url) {\n    url = url.split('?')[0].replace(/\\/$/, '');\n    existingUrls.add(url);\n  }\n  \n  const title = normalize(fields[\"Job Title\"] || \"\");\n  const company = normalize(fields[\"Company\"] || \"\");\n  if (title && company) {\n    existingKeys.add(title + \"|\" + company);\n  }\n}\n\nconst results = [];\n\nfor (const job of newJobs) {\n  let url = job.json.url || \"\";\n  if (url) {\n    url = url.split('?')[0].replace(/\\/$/, '');\n  }\n  \n  const title = normalize(job.json.title || \"\");\n  const company = normalize(job.json.company || \"\");\n  const key = title + \"|\" + company;\n  \n  const isGenericUrl = url.endsWith('/jobs') || url.endsWith('/remote-jobs');\n  if (url && !isGenericUrl && existingUrls.has(url)) continue;\n  \n  if (existingKeys.has(key)) continue;\n  \n  if (url && !isGenericUrl) existingUrls.add(url);\n  existingKeys.add(key);\n  \n  results.push(job);\n}\n\nreturn results.length ? results : [{ json: { _empty: true } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5280, 880],
      "id": "6d28c5ec-3210-4f5f-b709-9dd64707e60e",
      "name": "Dedup Against Airtable"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json._empty }}",
              "operation": "notEqual",
              "value2": true
            }
          ]
        }
      },
      "id": "075cfe34-f350-4ce8-a705-d6e8565b5e12",
      "name": "Filter Empty",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [6864, 880]
    },
    {
      "parameters": {
        "operation": "markAsRead",
        "messageId": "={{ $json.id }}"
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [4512, 1184],
      "id": "4f25ac5f-bca2-43a2-9ffd-04ef6367a0e9",
      "name": "Mark as Read",
      "webhookId": "db2ff5fd-2d5a-46b4-99db-280fc676c78d"
    },
    {
      "parameters": {
        "url": "https://raw.githubusercontent.com/zelman/tidepool/refs/heads/main/tide-pool-agent-lens.md",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [4400, 880],
      "id": "dc431bb1-c4f0-4583-aeb0-b2ee924fe054",
      "name": "Fetch Profile"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Builder vs Maintainer Pre-Filter\n// Quick signal check before expensive LLM calls\n\nconst CONFIG = {\n  minBuilderSignals: 1,\n  maxMaintainerSignals: 3,\n  maxCompanySize: 500,\n  seniorityRequired: [\"head\", \"director\", \"vp\", \"vice president\", \"chief\", \"lead\"],\n  minBaseSalary: 125000,\n};\n\nconst BUILDER_SIGNALS = [\n  \"build from scratch\", \"building the function\", \"first hire\", \"founding team\",\n  \"ground floor\", \"greenfield\", \"no playbook\", \"define the playbook\",\n  \"create the playbook\", \"build the team\", \"stand up\", \"establish the foundation\",\n  \"series a\", \"series b\", \"seed stage\", \"early stage\", \"early-stage\",\n  \"startup\", \"hypergrowth\", \"wear many hats\", \"player-coach\", \"hands-on leader\",\n  \"roll up your sleeves\", \"scrappy\", \"ambiguity\", \"build processes\",\n  \"define processes\", \"voice of customer\", \"growth lever\", \"strategic partner\",\n  \"report to ceo\", \"report to founder\", \"exec team\"\n];\n\nconst MAINTAINER_SIGNALS = [\n  \"book of business\", \"portfolio of accounts\", \"manage your accounts\",\n  \"own a portfolio\", \"retention targets\", \"renewal rate\", \"net retention\",\n  \"gross retention\", \"nrr\", \"grr\", \"churn reduction\", \"upsell quota\",\n  \"expansion targets\", \"expansion revenue\", \"cross-sell\", \"established processes\",\n  \"proven playbook\", \"existing team of\", \"maintain existing\", \"support the team\",\n  \"customer success manager\", \"manage relationships\", \"own the relationship\",\n  \"point of contact for\"\n];\n\nconst TITLE_EXCLUDES = [\n  \"customer success manager\", \"csm\", \"account manager\", \"account executive\",\n  \"representative\", \"specialist\", \"associate\", \"coordinator\", \"analyst\",\n  \"customer engagement manager\", \"escalation manager\", \"retention manager\",\n  \"renewal manager\", \"expansion manager\", \"growth manager\"\n];\n\n// Known large/public companies where enrichment may be unreliable\nconst KNOWN_LARGE_COMPANIES = [\n  \"anthropic\", \"openai\", \"google\", \"meta\", \"facebook\", \"amazon\", \"microsoft\",\n  \"apple\", \"netflix\", \"salesforce\", \"oracle\", \"ibm\", \"cisco\", \"intel\",\n  \"pinterest\", \"twitter\", \"x corp\", \"snap\", \"snapchat\", \"uber\", \"lyft\",\n  \"airbnb\", \"doordash\", \"instacart\", \"stripe\", \"plaid\", \"coinbase\",\n  \"honeywell\", \"ge\", \"general electric\", \"siemens\", \"3m\", \"boeing\",\n  \"lockheed\", \"raytheon\", \"northrop\", \"dell\", \"hp\", \"hewlett\"\n];\n\n// Healthcare compliance keywords - skills mismatch\nconst HEALTHCARE_COMPLIANCE_KEYWORDS = [\n  \"hipaa expertise\", \"hipaa required\", \"phi handling\", \"phi experience\",\n  \"healthcare compliance required\", \"healthcare regulatory\",\n  \"clinical compliance\", \"medical device regulatory\"\n];\n\nfunction countSignals(text, signals) {\n  return signals.filter(signal => text.includes(signal)).length;\n}\n\nfunction estimateRoleType(builder, maintainer) {\n  const ratio = builder / Math.max(1, maintainer);\n  if (ratio >= 2) return 'likely_builder';\n  if (ratio >= 1) return 'hybrid';\n  if (ratio >= 0.5) return 'leaning_maintainer';\n  return 'likely_maintainer';\n}\n\nconst jobData = $json;\n\n// Skip empty items\nif (jobData._empty) {\n  return { json: { ...jobData, _skip: true } };\n}\n\nconst title = (jobData['Job Title'] || '').toLowerCase();\nconst company = (jobData['Company'] || '').toLowerCase();\nconst description = ''; // We don't have full description at this stage, just title\nconst text = title;\n\n// Count signals from title only (description comes later from LLM)\nconst builderCount = countSignals(text, BUILDER_SIGNALS);\nconst maintainerCount = countSignals(text, MAINTAINER_SIGNALS);\n\n// Check title exclusions\nconst hasBadTitle = TITLE_EXCLUDES.some(exc => title.includes(exc));\n\n// Check seniority\nconst hasSeniority = CONFIG.seniorityRequired.some(level => title.includes(level));\n\n// Check for known large companies\nconst isKnownLargeCompany = KNOWN_LARGE_COMPANIES.some(c => company.includes(c));\n\n// Check for healthcare compliance requirements (skills mismatch)\nconst hasHealthcareCompliance = HEALTHCARE_COMPLIANCE_KEYWORDS.some(kw => title.includes(kw));\n\n// Decision logic - since we only have title, be more permissive\nlet shouldProcess = true;\nlet reason = null;\n\n// Hard reject obvious IC titles without seniority\nif (hasBadTitle && !hasSeniority) {\n  shouldProcess = false;\n  reason = `IC/CSM title (${title}) without leadership level`;\n}\n\n// Flag known large companies for auto-disqualify consideration\nlet isLargeCompanyFlag = false;\nif (isKnownLargeCompany) {\n  isLargeCompanyFlag = true;\n}\n\n// Flag healthcare compliance requirements\nlet hasSkillsMismatch = false;\nif (hasHealthcareCompliance) {\n  hasSkillsMismatch = true;\n}\n\nconst prefilterAnalysis = {\n  shouldProcess,\n  reason,\n  builderSignals: builderCount,\n  maintainerSignals: maintainerCount,\n  signalRatio: builderCount / Math.max(1, maintainerCount),\n  hasSeniority,\n  estimatedRoleType: estimateRoleType(builderCount, maintainerCount),\n  isKnownLargeCompany: isLargeCompanyFlag,\n  hasSkillsMismatch: hasSkillsMismatch\n};\n\nreturn {\n  json: {\n    ...jobData,\n    prefilterAnalysis\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5728, 1088],
      "id": "6eb7fb37-bde7-42ed-962e-7c2b3c7f7a58",
      "name": "Prefilter: Builder vs Maintainer"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.prefilterAnalysis.shouldProcess }}",
              "value2": true
            }
          ]
        }
      },
      "id": "8cd84b40-107e-4ef7-ac10-3d9ec8086b1c",
      "name": "IF: Should Process",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [5840, 1088]
    },
    {
      "parameters": {},
      "id": "36c07ec8-2e02-4d04-aa73-abaa82ac97a0",
      "name": "Skip Filtered Jobs",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [5840, 1280]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://api.search.brave.com/res/v1/web/search",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "q",
              "value": "={{ `\"${$json['Company']}\" funding series employees site:crunchbase.com OR site:pitchbook.com OR site:tracxn.com` }}"
            },
            {
              "name": "count",
              "value": "5"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [5952, 1088],
      "id": "brave-search-company",
      "name": "Brave Search Company"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Parse Brave Search results for company enrichment\nconst jobData = $('IF: Should Process').item.json;\nconst braveResults = $json.web?.results || [];\n\nlet enrichment = {\n  employeeCount: null,\n  fundingStage: null,\n  totalFunding: null,\n  isPEBacked: false,\n  isVCBacked: false,\n  foundedYear: null,\n  companyAge: null,\n  enrichmentSource: null,\n  rawSnippets: []\n};\n\n// Combine all result text for analysis\nconst combinedText = braveResults\n  .map(r => `${r.title || ''} ${r.description || ''}`)\n  .join(' ')\n  .toLowerCase();\n\n// Store raw snippets for debugging\nenrichment.rawSnippets = braveResults.slice(0, 3).map(r => (r.description || '').substring(0, 200));\n\n// Extract employee count - multiple patterns\nconst empPatterns = [\n  /(\\d{1,3}(?:,\\d{3})*)\\s*(?:\\+\\s*)?employees/i,\n  /(\\d{1,3}(?:,\\d{3})*)\\s*(?:-|to|–)\\s*(\\d{1,3}(?:,\\d{3})*)\\s*employees/i,\n  /employees?:?\\s*(\\d{1,3}(?:,\\d{3})*)/i,\n  /team\\s+(?:of\\s+)?(\\d{1,3}(?:,\\d{3})*)/i,\n  /headcount:?\\s*(\\d{1,3}(?:,\\d{3})*)/i\n];\n\nfor (const pattern of empPatterns) {\n  const match = combinedText.match(pattern);\n  if (match) {\n    const num1 = parseInt((match[1] || '').replace(/,/g, ''));\n    const num2 = match[2] ? parseInt(match[2].replace(/,/g, '')) : null;\n    enrichment.employeeCount = num2 ? Math.max(num1, num2) : num1;\n    break;\n  }\n}\n\n// Extract funding stage - ordered by latest stage\nconst stagePatterns = [\n  { pattern: /(?:ipo|went public|publicly traded|nasdaq|nyse)/i, stage: 'Public' },\n  { pattern: /series\\s*[d-z]\\b/i, stage: 'Series D+' },\n  { pattern: /series\\s*c\\b/i, stage: 'Series C' },\n  { pattern: /series\\s*b\\b/i, stage: 'Series B' },\n  { pattern: /series\\s*a\\b/i, stage: 'Series A' },\n  { pattern: /seed\\s+(?:round|funding|stage)/i, stage: 'Seed' },\n  { pattern: /pre[- ]?seed/i, stage: 'Pre-Seed' },\n  { pattern: /bootstrapped/i, stage: 'Bootstrapped' }\n];\n\nfor (const { pattern, stage } of stagePatterns) {\n  if (pattern.test(combinedText)) {\n    enrichment.fundingStage = stage;\n    break;\n  }\n}\n\n// Extract total funding amount\n// Prioritize explicit patterns, require word boundaries to avoid false matches\nconst fundingPatterns = [\n  /(?:raised|funding|total\\s+funding)[^$]*\\$([\\d.]+)\\s*(billion)\\b/i,\n  /(?:raised|funding|total\\s+funding)[^$]*\\$([\\d.]+)\\s*(million|m)\\b/i,\n  /\\$([\\d.]+)\\s*(billion)\\s*(?:raised|funding|in\\s+funding)/i,\n  /\\$([\\d.]+)\\s*(million|m)\\s*(?:raised|funding|in\\s+funding)/i,\n  /(?:funding|raised):\\s*\\$([\\d.]+)\\s*(billion|million|m)?/i\n];\n\nfor (const pattern of fundingPatterns) {\n  const match = combinedText.match(pattern);\n  if (match) {\n    let amount = parseFloat(match[1]);\n    const unit = (match[2] || 'm').toLowerCase();\n    // Only treat 'billion' as billions (not single 'b' which could be series B)\n    if (unit === 'billion') {\n      amount *= 1000;\n    }\n    enrichment.totalFunding = amount;\n    break;\n  }\n}\n\n// Check PE vs VC backing - comprehensive PE firm list\nconst PE_FIRMS = [\n  'vista equity', 'thoma bravo', 'kkr', 'blackstone', 'carlyle',\n  'bain capital', 'tpg', 'apollo', 'warburg pincus', 'silver lake',\n  'francisco partners', 'ares management', 'golden gate capital',\n  'insight partners', 'vector capital', 'ta associates', 'nordic capital',\n  'hellman friedman', 'permira', 'advent international', 'cinven',\n  'eqt partners', 'cvc capital', 'bc partners', 'apax partners',\n  'general atlantic', 'summit partners', 'providence equity',\n  'welsh carson', 'gtcr', 'leonard green', 'american securities',\n  'clearlake capital', 'platinum equity', 'kohlberg'\n];\nconst pePatterns = /private\\s+equity|pe[- ]backed|buyout|lbo|acquired\\s+by.*(?:capital|partners)/i;\nconst peByName = PE_FIRMS.some(firm => combinedText.includes(firm));\nconst vcPatterns = /venture\\s+capital|vc[- ]backed|backed\\s+by|investors?\\s+include|a16z|sequoia|accel|greylock|benchmark|andreessen/i;\n\nenrichment.isPEBacked = pePatterns.test(combinedText) || peByName;\nenrichment.isVCBacked = vcPatterns.test(combinedText) && !enrichment.isPEBacked;\n\n// Check for known large company flag from prefilter\nconst prefilterData = jobData.prefilterAnalysis || {};\nif (prefilterData.isKnownLargeCompany) {\n  enrichment.isKnownLarge = true;\n  if (!enrichment.autoDisqualifiers) enrichment.autoDisqualifiers = [];\n}\n\n// Check for skills mismatch from prefilter\nif (prefilterData.hasSkillsMismatch) {\n  enrichment.hasSkillsMismatch = true;\n}\n\n// Founded year\nconst foundedPatterns = [\n  /founded\\s*(?:in\\s*)?(\\d{4})/i,\n  /established\\s*(?:in\\s*)?(\\d{4})/i,\n  /since\\s+(\\d{4})/i,\n  /started\\s*(?:in\\s*)?(\\d{4})/i\n];\n\nfor (const pattern of foundedPatterns) {\n  const match = combinedText.match(pattern);\n  if (match) {\n    const year = parseInt(match[1]);\n    if (year >= 1900 && year <= new Date().getFullYear()) {\n      enrichment.foundedYear = year;\n      enrichment.companyAge = new Date().getFullYear() - year;\n      break;\n    }\n  }\n}\n\n// Track source URL\nif (braveResults.length > 0) {\n  const crunchbaseResult = braveResults.find(r => r.url?.includes('crunchbase.com'));\n  enrichment.enrichmentSource = crunchbaseResult?.url || braveResults[0].url;\n}\n\n// Calculate auto-disqualifiers based on Tide Pool criteria\nenrichment.autoDisqualifiers = [];\nif (enrichment.isPEBacked) {\n  enrichment.autoDisqualifiers.push('PE-backed company');\n}\nif (enrichment.employeeCount && enrichment.employeeCount >= 1000) {\n  enrichment.autoDisqualifiers.push(`${enrichment.employeeCount} employees (>=1000)`);\n}\nif (enrichment.totalFunding && enrichment.totalFunding >= 500) {\n  const fundingDisplay = enrichment.totalFunding >= 1000 ? `$${(enrichment.totalFunding / 1000).toFixed(1)}B` : `$${enrichment.totalFunding}M`;\n  enrichment.autoDisqualifiers.push(`${fundingDisplay} funding (>=500M)`);\n}\nif (enrichment.fundingStage === 'Public') {\n  enrichment.autoDisqualifiers.push('Public company');\n}\nif (enrichment.isKnownLarge) {\n  enrichment.autoDisqualifiers.push('Known large/public company');\n}\nif (enrichment.hasSkillsMismatch) {\n  enrichment.autoDisqualifiers.push('Healthcare compliance skills required');\n}\n\n// Zombie company detection: old + still early stage = stalled growth\nif (enrichment.companyAge && enrichment.companyAge >= 7) {\n  const earlyStages = ['Seed', 'Pre-Seed', 'Bootstrapped', null];\n  const isStillEarly = earlyStages.includes(enrichment.fundingStage);\n  const isSmall = !enrichment.employeeCount || enrichment.employeeCount < 100;\n  \n  if (isStillEarly && isSmall) {\n    enrichment.autoDisqualifiers.push(\n      `Stalled company (${enrichment.companyAge}yr old, still ${enrichment.fundingStage || 'early stage'}, <100 emp)`\n    );\n  }\n}\n\nreturn {\n  json: {\n    ...jobData,\n    _enrichment: enrichment,\n    _braveResultCount: braveResults.length,\n    _hasAutoDisqualifier: enrichment.autoDisqualifiers.length > 0\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [6064, 1088],
      "id": "parse-enrichment",
      "name": "Parse Enrichment"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build comprehensive prompt for Claude API - with Brave Search enrichment\nconst jobData = $json;\nconst profileData = $('Fetch Profile').first().json;\nconst profileRaw = profileData.data || profileData;\n\n// Get the profile content as string\nconst profileContent = typeof profileRaw === 'string' ? profileRaw : JSON.stringify(profileRaw);\n\n// Get API key from Airtable Config\nconst configData = $('Get Config').first().json;\nconst apiKey = configData.fields?.Value || configData.Value || '';\n\n// Skip empty items\nif (jobData._empty || jobData._skip) {\n  return { json: { ...jobData, _skip: true } };\n}\n\n// Get enrichment data\nconst enrichment = jobData._enrichment || {};\n\n// Build system prompt dynamically from the fetched Tide Pool profile\nconst systemPrompt = `You are a job matching assistant. Use the following personal profile to evaluate job opportunities.\n\n=== CANDIDATE PROFILE (Tide Pool Agent Lens) ===\n${profileContent}\n=== END PROFILE ===\n\n## Your Task\nAnalyze the job posting against the profile above. Pay special attention to:\n1. The \"Job Search Parameters\" section for ideal company fit criteria\n2. The \"Auto-Disqualifiers\" - these are HARD NO criteria\n3. The \"Opportunity Scoring Framework\" for how to score\n4. The \"Role Type Exclusions\" section\n5. The \"Title Flexibility\" guidance for early-stage companies\n\n## Critical Distinction: BUILDER vs MAINTAINER\nThis candidate wants BUILDER roles (creating from scratch) NOT MAINTAINER roles (managing existing).\n\n**BUILDER signals:** build from scratch, first hire, founding team, greenfield, define playbook, series A/B, startup, player-coach, hands-on\n**MAINTAINER signals:** book of business, portfolio of accounts, retention targets, renewal rate, established processes, proven playbook\n\n## IMPORTANT: Company Enrichment Data\nYou have been provided with verified company data from web search. Use this data to:\n1. IMMEDIATELY DISQUALIFY if any auto-disqualifier is present (PE-backed, 1000+ employees, $500M+ funding, public company)\n2. Accurately score company stage (this is worth up to 50 points!)\n3. Apply bonus points for VC-backed, recently founded, etc.\n\n## Response Format\nRespond with ONLY valid JSON:\n{\n  \"score\": <0-100 using the scoring framework from profile>,\n  \"role_type\": \"builder\" | \"maintainer\" | \"hybrid\",\n  \"is_dealbreaker\": <true/false based on auto-disqualifiers>,\n  \"dealbreaker_reason\": \"<reason if dealbreaker, null otherwise>\",\n  \"score_breakdown\": {\n    \"company_stage_fit\": <0-50>,\n    \"role_type\": <0-30>,\n    \"mission_alignment\": <0-20>\n  },\n  \"builder_evidence\": [<quotes/signals suggesting builder role>],\n  \"maintainer_evidence\": [<quotes/signals suggesting maintainer role>],\n  \"industry\": \"<company's industry>\",\n  \"company_stage_detected\": \"<pre_a|series_a|series_b|series_c|growth|late|public|unknown>\",\n  \"company_size_detected\": \"<number or range if mentioned, null if not>\",\n  \"salary_detected\": { \"base_min\": <number or null>, \"base_max\": <number or null>, \"has_equity\": <true/false/null> },\n  \"what_excites\": [<aspects that align with profile>],\n  \"concerns\": [<red flags or misalignments>],\n  \"recommendation\": \"apply\" | \"research\" | \"skip\",\n  \"summary\": \"<2-3 sentence assessment focused on builder vs maintainer fit>\"\n}`;\n\n// Include prefilter analysis in the prompt\nconst prefilterInfo = jobData.prefilterAnalysis ? \n  `\\nPREFILTER ANALYSIS (from title only):\\n- Estimated role type: ${jobData.prefilterAnalysis.estimatedRoleType}\\n- Has seniority: ${jobData.prefilterAnalysis.hasSeniority}` : '';\n\n// Build enrichment block for prompt\nconst fundingDisplay = enrichment.totalFunding ? (enrichment.totalFunding >= 1000 ? '$' + (enrichment.totalFunding / 1000).toFixed(1) + 'B' : '$' + enrichment.totalFunding + 'M') : 'Unknown';\nconst enrichmentBlock = `\nCOMPANY ENRICHMENT DATA (verified from web search - USE THIS FOR SCORING):\n- Employee Count: ${enrichment.employeeCount || 'Unknown'}\n- Funding Stage: ${enrichment.fundingStage || 'Unknown'}\n- Total Funding: ${fundingDisplay}\n- PE-Backed: ${enrichment.isPEBacked ? 'YES - AUTO-DISQUALIFIER!' : 'No'}\n- VC-Backed: ${enrichment.isVCBacked ? 'Yes (+10 bonus)' : 'Unknown'}\n- Founded: ${enrichment.foundedYear || 'Unknown'}${enrichment.companyAge ? ' (' + enrichment.companyAge + ' years old)' : ''}${enrichment.companyAge && enrichment.companyAge <= 3 ? ' - RECENT (+10 bonus)' : ''}\n- Enrichment Source: ${enrichment.enrichmentSource || 'No results found'}\n${enrichment.autoDisqualifiers?.length > 0 ? '\\n⚠️ AUTO-DISQUALIFIERS DETECTED: ' + enrichment.autoDisqualifiers.join(', ') : ''}\n`;\n\nconst userPrompt = `Analyze this job posting using the Tide Pool profile criteria above.${prefilterInfo}\n\nJOB POSTING:\nTitle: ${jobData['Job Title']}\nCompany: ${jobData['Company']}\nLocation: ${jobData['Location']}\nSalary: ${jobData['Salary Info']}\nSource: ${jobData['Source']}\n${enrichmentBlock}\nNote: Full job description not available - analyze based on title, company context, and the enrichment data above.\n\nApply the scoring framework from the profile and return JSON. Remember to use the enrichment data for accurate company stage scoring!`;\n\nreturn {\n  json: {\n    ...jobData,\n    _systemPrompt: systemPrompt,\n    _userPrompt: userPrompt,\n    _apiKey: apiKey\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [6400, 1088],
      "id": "6a79bb13-e3a7-4589-bacd-239632047e09",
      "name": "Build Prompt"
    },
    {
      "parameters": {
        "amount": 30
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [6512, 1088],
      "id": "a4aa0f8f-4ada-4c53-b222-0775c2d1f819",
      "name": "Wait (Rate Limit)",
      "webhookId": "rate-limit-wait"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "={{ $json._apiKey }}"
            },
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"claude-3-haiku-20240307\",\n  \"max_tokens\": 2000,\n  \"system\": {{ JSON.stringify($json._systemPrompt) }},\n  \"messages\": [{\"role\": \"user\", \"content\": {{ JSON.stringify($json._userPrompt) }}}]\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [6624, 1088],
      "id": "cf355c66-bb75-4ed4-b231-7b2fa48d92c9",
      "name": "Call Claude API",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Parse Claude response - Robust JSON parsing with enrichment data\nconst input = $json;\nconst jobData = $('Build Prompt').item.json;\n\n// Skip if marked to skip\nif (jobData._skip) {\n  return { json: jobData };\n}\n\nlet fitScore = 0;\nlet fitRationale = 'Unable to rate';\nlet industry = '';\nlet companyStage = '';\nlet roleType = '';\nlet builderEvidence = '';\nlet maintainerEvidence = '';\nlet recommendation = '';\n\n// Get enrichment data\nconst enrichment = jobData._enrichment || {};\n\n// Helper to safely extract JSON from text\nfunction extractJSON(text) {\n  let depth = 0;\n  let start = -1;\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] === '{') {\n      if (depth === 0) start = i;\n      depth++;\n    } else if (text[i] === '}') {\n      depth--;\n      if (depth === 0 && start !== -1) {\n        return text.substring(start, i + 1);\n      }\n    }\n  }\n  return null;\n}\n\ntry {\n  if (input.content && input.content[0] && input.content[0].text) {\n    const content = input.content[0].text;\n    const jsonStr = extractJSON(content);\n    \n    if (jsonStr) {\n      const cleaned = jsonStr\n        .replace(/,\\s*}/g, '}')\n        .replace(/,\\s*]/g, ']')\n        .replace(/\\n/g, ' ')\n        .replace(/\\t/g, ' ')\n        .replace(/\"\\s+\"/g, '\", \"')\n        .replace(/]\\s*\"/g, '], \"')\n        .replace(/\"\\s*\\[/g, '\": [')\n        .replace(/}\\s*\"/g, '}, \"');\n      \n      const parsed = JSON.parse(cleaned);\n      \n      fitScore = parsed.score || 0;\n      roleType = parsed.role_type || '';\n      recommendation = parsed.recommendation || '';\n      fitRationale = parsed.summary || 'No summary provided';\n      companyStage = parsed.company_stage_detected || enrichment.fundingStage || '';\n      industry = parsed.industry || '';\n      \n      if (parsed.builder_evidence) {\n        const arr = Array.isArray(parsed.builder_evidence) ? parsed.builder_evidence : [parsed.builder_evidence];\n        builderEvidence = arr.slice(0, 3).join('; ');\n      }\n      if (parsed.maintainer_evidence) {\n        const arr = Array.isArray(parsed.maintainer_evidence) ? parsed.maintainer_evidence : [parsed.maintainer_evidence];\n        maintainerEvidence = arr.slice(0, 3).join('; ');\n      }\n      \n      if (parsed.is_dealbreaker && parsed.dealbreaker_reason) {\n        fitRationale = `DEALBREAKER: ${parsed.dealbreaker_reason}. ${fitRationale}`;\n      }\n    } else {\n      fitRationale = 'Could not extract JSON from response';\n    }\n  } else if (input.error) {\n    fitRationale = 'API Error: ' + (input.error.message || JSON.stringify(input.error));\n  }\n} catch (e) {\n  // Fallback: try to extract key values via regex if JSON parsing fails\n  const content = input.content?.[0]?.text || '';\n  const scoreMatch = content.match(/\"score\"\\s*:\\s*(\\d+)/i);\n  const roleMatch = content.match(/\"role_type\"\\s*:\\s*\"(builder|maintainer|hybrid)\"/i);\n  const recMatch = content.match(/\"recommendation\"\\s*:\\s*\"(apply|research|skip)\"/i);\n  const summaryMatch = content.match(/\"summary\"\\s*:\\s*\"([^\"]+)\"/i);\n  const industryMatch = content.match(/\"industry\"\\s*:\\s*\"([^\"]+)\"/i);\n  const stageMatch = content.match(/\"company_stage_detected\"\\s*:\\s*\"([^\"]+)\"/i);\n  \n  if (scoreMatch || summaryMatch) {\n    fitScore = scoreMatch ? parseInt(scoreMatch[1]) : 0;\n    roleType = roleMatch ? roleMatch[1] : '';\n    recommendation = recMatch ? recMatch[1] : '';\n    fitRationale = summaryMatch ? summaryMatch[1] : 'Partial parse - see score';\n    industry = industryMatch ? industryMatch[1] : '';\n    companyStage = stageMatch ? stageMatch[1] : enrichment.fundingStage || '';\n  } else {\n    fitRationale = 'Parse Error: ' + e.message;\n  }\n}\n\n// Append enrichment data to rationale\nconst enrichmentParts = [];\nif (enrichment.employeeCount) enrichmentParts.push(`Employees: ${enrichment.employeeCount}`);\nif (enrichment.totalFunding) {\n  const fundingStr = enrichment.totalFunding >= 1000 ? `$${(enrichment.totalFunding / 1000).toFixed(1)}B` : `$${enrichment.totalFunding}M`;\n  enrichmentParts.push(`Funding: ${fundingStr}`);\n}\nif (enrichment.isPEBacked) enrichmentParts.push('PE-backed');\nif (enrichment.isVCBacked) enrichmentParts.push('VC-backed');\nif (enrichment.foundedYear) enrichmentParts.push(`Founded: ${enrichment.foundedYear}`);\nif (enrichmentParts.length > 0) {\n  fitRationale = fitRationale + ' | Enrichment: ' + enrichmentParts.join(', ');\n}\n\n// Remove internal fields before returning\nconst { _systemPrompt, _userPrompt, _skip, _apiKey, prefilterAnalysis, _enrichment, _braveResultCount, _hasAutoDisqualifier, _emailId, ...cleanJobData } = jobData;\n\nreturn {\n  json: {\n    ...cleanJobData,\n    'Tide-Pool Score': fitScore,\n    'Tide-Pool Rationale': fitRationale,\n    'Industry': industry,\n    'Company Stage': companyStage,\n    'Role Type': roleType,\n    'Builder Evidence': builderEvidence,\n    'Maintainer Evidence': maintainerEvidence,\n    'Recommendation': recommendation\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [6736, 1088],
      "id": "eca7e2e5-dbba-456a-b34b-9055cdbd65ed",
      "name": "Parse Response"
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "value": "appFEzXvPWvRtXgRY",
          "mode": "list",
          "cachedResultName": "Job search",
          "cachedResultUrl": "https://airtable.com/appFEzXvPWvRtXgRY"
        },
        "table": {
          "__rl": true,
          "value": "tblofzQpzGEN8igVS",
          "mode": "id"
        },
        "filterByFormula": "{Key} = 'ANTHROPIC_API_KEY'",
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [4848, 992],
      "id": "ba3b2496-c556-44f0-abc3-c6f245195265",
      "name": "Get Config"
    }
  ],
  "connections": {
    "Identify Source": {
      "main": [
        [
          {
            "node": "Parse Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Jobs": {
      "main": [
        [
          {
            "node": "Has Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Jobs": {
      "main": [
        [
          {
            "node": "Merge Inputs",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Jobs Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Fields for Airtable": {
      "main": [
        [
          {
            "node": "Prefilter: Builder vs Maintainer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prefilter: Builder vs Maintainer": {
      "main": [
        [
          {
            "node": "IF: Should Process",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF: Should Process": {
      "main": [
        [
          {
            "node": "Brave Search Company",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip Filtered Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Brave Search Company": {
      "main": [
        [
          {
            "node": "Parse Enrichment",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Enrichment": {
      "main": [
        [
          {
            "node": "Build Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Prompt": {
      "main": [
        [
          {
            "node": "Wait (Rate Limit)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait (Rate Limit)": {
      "main": [
        [
          {
            "node": "Call Claude API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Claude API": {
      "main": [
        [
          {
            "node": "Parse Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Response": {
      "main": [
        [
          {
            "node": "Filter Empty",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get many messages": {
      "main": [
        [
          {
            "node": "Mark as Read",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark as Read": {
      "main": [
        [
          {
            "node": "Identify Source",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Get many messages",
            "type": "main",
            "index": 0
          },
          {
            "node": "Search records",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Config",
            "type": "main",
            "index": 0
          },
          {
            "node": "Fetch Profile",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add to Airtable": {
      "main": [
        [
          {
            "node": "Add label to message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search records": {
      "main": [
        [
          {
            "node": "Merge Inputs",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Inputs": {
      "main": [
        [
          {
            "node": "Dedup Against Airtable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dedup Against Airtable": {
      "main": [
        [
          {
            "node": "Map Fields for Airtable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Empty": {
      "main": [
        [
          {
            "node": "Add to Airtable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": true,
    "timeSavedMode": "fixed",
    "callerPolicy": "workflowsFromSameOwner"
  },
  "meta": {
    "templateCredsSetupCompleted": true
  }
}
