{
  "name": "Work at a Startup Scraper v4",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 6
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.3,
      "position": [-4000, -80],
      "id": "07904d1d-5321-4561-9c5f-2f56c567ece6",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "value": "appFEzXvPWvRtXgRY",
          "mode": "id"
        },
        "table": {
          "__rl": true,
          "value": "tblofzQpzGEN8igVS",
          "mode": "id"
        },
        "filterByFormula": "OR({Key} = 'YC_USER', {Key} = 'YC_PASSWORD', {Key} = 'BROWSERLESS_TOKEN', {Key} = 'ANTHROPIC_API_KEY')",
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [-3792, -176],
      "id": "4245412e-f535-4750-ad72-5d9fdf3a7536",
      "name": "Get Config"
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "value": "appFEzXvPWvRtXgRY",
          "mode": "id"
        },
        "table": {
          "__rl": true,
          "value": "tbl6ZV2rHjWz56pP3",
          "mode": "id"
        },
        "filterByFormula": "IS_AFTER({Date Found}, DATEADD(TODAY(), -30, 'days'))",
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [-3792, 32],
      "id": "59457566-725e-4f7a-a8f2-aa5465179599",
      "name": "Search Existing Jobs"
    },
    {
      "parameters": {
        "jsCode": "// Extract config values\nconst items = $input.all();\nconst config = {};\n\nfor (const item of items) {\n  const key = item.json.fields?.Key || item.json.Key;\n  const value = item.json.fields?.Value || item.json.Value;\n  if (key && value) {\n    config[key] = value;\n  }\n}\n\nreturn [{ json: config }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-3600, -176],
      "id": "91c8c24f-12f1-4306-b584-9f92d92399ac",
      "name": "Parse Config"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://chrome.browserless.io/function?token={{ $json.BROWSERLESS_TOKEN }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ context: { ycUser: $json.YC_USER, ycPassword: $json.YC_PASSWORD }, code: `export default async ({ page, context }) => { const { ycUser, ycPassword } = context; const jobsUrl = 'https://www.workatastartup.com/companies?demographic=any&hasEquity=any&hasSalary=any&industry=any&interviewProcess=any&jobType=any&layout=list-compact&role=support&sortBy=keyword&tab=any&usVisaNotRequired=any'; const sleep = ms => new Promise(r => setTimeout(r, ms)); try { page.setDefaultTimeout(60000); await page.goto('https://www.workatastartup.com/', { waitUntil: 'networkidle2', timeout: 30000 }); await sleep(2000); const needsLogin = await page.evaluate(() => !document.cookie.includes('_sso_session')); if (needsLogin) { await page.goto('https://account.ycombinator.com/authenticate?continue=' + encodeURIComponent(jobsUrl), { waitUntil: 'networkidle2', timeout: 30000 }); await sleep(2000); const hasLoginForm = await page.$('#ycid-input'); if (hasLoginForm) { await page.type('#ycid-input', ycUser, { delay: 30 }); await sleep(500); await page.type('#password-input', ycPassword, { delay: 30 }); await sleep(500); await Promise.all([ page.click('button[type=\"submit\"]'), page.waitForNavigation({ waitUntil: 'networkidle2', timeout: 30000 }).catch(() => {}) ]); await sleep(3000); } } await page.goto(jobsUrl, { waitUntil: 'networkidle2', timeout: 45000 }); await sleep(3000); await page.waitForSelector('body', { timeout: 10000 }); for (let i = 0; i < 5; i++) { await page.evaluate(() => { if (document.body) window.scrollTo(0, document.body.scrollHeight); }); await sleep(2000); } const jobs = await page.evaluate(() => { const results = []; const seen = new Set(); document.querySelectorAll('a[href*=\"/jobs/\"]').forEach(link => { const href = link.getAttribute('href'); if (!href || seen.has(href)) return; seen.add(href); const url = href.startsWith('http') ? href : 'https://www.workatastartup.com' + href; const card = link.closest('div'); const cardText = card ? card.innerText : link.innerText; const lines = cardText.split('\\\\n').map(l => l.trim()).filter(l => l); let title = ''; let company = ''; let location = 'Not specified'; for (const line of lines) { if (!title && (line.includes('Manager') || line.includes('Director') || line.includes('Head') || line.includes('Lead') || line.includes('Engineer') || line.includes('VP'))) { title = line; } if (!company && line.match(/\\\\([SWF][0-9]+\\\\)/)) { company = line; } } if (!title) title = lines[0] || link.innerText.trim(); const locPatterns = ['Remote', 'San Francisco', 'New York', 'Boston', 'Los Angeles', 'Seattle', 'Austin', 'Chicago', 'Denver', 'Miami', 'London', 'Berlin', 'Hybrid']; for (const loc of locPatterns) { if (cardText.includes(loc)) { location = loc; break; } } const batchMatch = cardText.match(/\\\\(([SWF][0-9]+)\\\\)/); const ycBatch = batchMatch ? 'YC ' + batchMatch[1] : ''; if (title && title.length > 3) { results.push({ title, company: company || 'Unknown', location, url, ycBatch, jobId: 'waas-' + Date.now() + '-' + results.length }); } }); return results; }); return { type: 'application/json', data: jobs, debug: { url: page.url(), jobCount: jobs.length } }; } catch (error) { return { type: 'application/json', data: [{ error: error.message, stack: error.stack }] }; } };` }) }}",
        "options": {
          "timeout": 120000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [-3392, -176],
      "id": "4d764b08-9a1b-4b70-8f2c-36d660c3e0c0",
      "name": "Scrape via Browserless"
    },
    {
      "parameters": {
        "jsCode": "// Parse Browserless response and filter jobs\nconst response = $input.first().json;\n\nlet jobs = [];\nif (response.data && response.data.jobs) {\n  jobs = response.data.jobs;\n} else if (response.data && Array.isArray(response.data)) {\n  jobs = response.data;\n} else if (Array.isArray(response)) {\n  jobs = response;\n} else if (response.error) {\n  return [{ json: { error: response.error } }];\n}\n\n// Filter for support/success leadership roles\nconst supportKeywords = ['support', 'success', 'customer', 'client', 'cx', 'experience'];\nconst leadershipKeywords = ['manager', 'director', 'vp', 'vice president', 'head', 'lead', 'chief', 'supervisor', 'team lead'];\n\nconst filteredJobs = jobs.filter(job => {\n  if (job.error) return false;\n  const title = (job.title || '').toLowerCase();\n  const hasSupport = supportKeywords.some(kw => title.includes(kw));\n  const hasLeadership = leadershipKeywords.some(kw => title.includes(kw));\n  return hasSupport && hasLeadership;\n});\n\nif (filteredJobs.length === 0) {\n  return [{ json: { _empty: true, _rawCount: jobs.length, _message: 'No jobs matched both support AND leadership keywords' } }];\n}\n\nreturn filteredJobs.map(job => ({\n  json: {\n    \"Job Title\": job.title,\n    \"Company\": job.company,\n    \"Location\": job.location || 'Not specified',\n    \"Source\": 'Work at a Startup',\n    \"Job URL\": job.url,\n    \"Job ID\": job.jobId,\n    \"Salary Info\": job.salary || 'Not specified',\n    \"Date Found\": new Date().toISOString().split('T')[0],\n    \"Review Status\": \"New\",\n    \"_ycBatch\": job.ycBatch || '',\n    \"_scrapedIndustry\": job.industry || ''\n  }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-3200, -176],
      "id": "f8264261-5d7f-417c-be45-f342230e9d90",
      "name": "Parse & Filter"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [-2992, -80],
      "id": "9b40d2ad-c5cc-45d4-8820-d14cc4a8436a",
      "name": "Merge for Dedup"
    },
    {
      "parameters": {
        "jsCode": "// Dedup scraped jobs against existing Airtable records\n\nconst normalize = (str) => {\n  if (!str) return '';\n  return str.toLowerCase().replace(/[^a-z0-9]/g, '').trim();\n};\n\nconst allItems = $input.all();\n\n// Separate new jobs from existing Airtable records\nconst newJobs = allItems.filter(item => \n  item.json['Job Title'] && item.json['Source'] === 'Work at a Startup' && !item.json.fields\n);\n\nconst existingRecords = allItems.filter(item => \n  item.json.fields || (item.json['Job URL'] && !item.json['_ycBatch'])\n);\n\n// Build sets of existing URLs and normalized title+company keys\nconst existingUrls = new Set();\nconst existingKeys = new Set();\n\nfor (const item of existingRecords) {\n  const fields = item.json.fields || item.json;\n  \n  // Add URL (normalized - remove trailing slashes, params)\n  let url = fields['Job URL'] || '';\n  if (url) {\n    url = url.split('?')[0].replace(/\\/$/, '');\n    existingUrls.add(url);\n  }\n  \n  // Add normalized title+company key\n  const title = normalize(fields['Job Title'] || '');\n  const company = normalize(fields['Company'] || '');\n  if (title && company) {\n    existingKeys.add(title + '|' + company);\n  }\n}\n\n// Filter new jobs against existing\nconst results = [];\nconst addedUrls = new Set();\nconst addedKeys = new Set();\n\nfor (const job of newJobs) {\n  // Skip empty markers\n  if (job.json._empty) continue;\n  \n  // Normalize URL\n  let url = job.json['Job URL'] || '';\n  if (url) {\n    url = url.split('?')[0].replace(/\\/$/, '');\n  }\n  \n  // Normalize title and company\n  const title = normalize(job.json['Job Title'] || '');\n  const company = normalize(job.json['Company'] || '');\n  const key = title + '|' + company;\n  \n  // Skip if URL already exists in Airtable or this batch\n  if (url && (existingUrls.has(url) || addedUrls.has(url))) continue;\n  \n  // Skip if title+company combo exists\n  if (existingKeys.has(key) || addedKeys.has(key)) continue;\n  \n  // Add to tracking sets\n  if (url) addedUrls.add(url);\n  addedKeys.add(key);\n  \n  results.push(job);\n}\n\nreturn results.length ? results : [{ json: { _empty: true } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-2800, -80],
      "id": "1495d51c-c224-44e5-adb5-db5701d3d35d",
      "name": "Dedup Against Airtable"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json._empty }}",
              "operation": "notEqual",
              "value2": true
            },
            {
              "value1": "={{ $json.error }}",
              "operation": "isEmpty"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [-2592, -80],
      "id": "601b7f43-cb8d-44b3-aab6-65054524cb51",
      "name": "Has Jobs?"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Builder vs Maintainer Pre-Filter\n// Quick signal check before expensive LLM calls\n\nconst CONFIG = {\n  minBuilderSignals: 1,\n  maxMaintainerSignals: 3,\n  maxCompanySize: 500,\n  seniorityRequired: [\"head\", \"director\", \"vp\", \"vice president\", \"chief\", \"lead\"],\n  minBaseSalary: 125000,\n};\n\nconst BUILDER_SIGNALS = [\n  \"build from scratch\", \"building the function\", \"first hire\", \"founding team\",\n  \"ground floor\", \"greenfield\", \"no playbook\", \"define the playbook\",\n  \"create the playbook\", \"build the team\", \"stand up\", \"establish the foundation\",\n  \"series a\", \"series b\", \"seed stage\", \"early stage\", \"early-stage\",\n  \"startup\", \"hypergrowth\", \"wear many hats\", \"player-coach\", \"hands-on leader\",\n  \"roll up your sleeves\", \"scrappy\", \"ambiguity\", \"build processes\",\n  \"define processes\", \"voice of customer\", \"growth lever\", \"strategic partner\",\n  \"report to ceo\", \"report to founder\", \"exec team\"\n];\n\nconst MAINTAINER_SIGNALS = [\n  \"book of business\", \"portfolio of accounts\", \"manage your accounts\",\n  \"own a portfolio\", \"retention targets\", \"renewal rate\", \"net retention\",\n  \"gross retention\", \"nrr\", \"grr\", \"churn reduction\", \"upsell quota\",\n  \"expansion targets\", \"expansion revenue\", \"cross-sell\", \"established processes\",\n  \"proven playbook\", \"existing team of\", \"maintain existing\", \"support the team\",\n  \"customer success manager\", \"manage relationships\", \"own the relationship\",\n  \"point of contact for\"\n];\n\nconst TITLE_EXCLUDES = [\n  \"customer success manager\", \"csm\", \"account manager\", \"account executive\",\n  \"representative\", \"specialist\", \"associate\", \"coordinator\", \"analyst\"\n];\n\nfunction countSignals(text, signals) {\n  return signals.filter(signal => text.includes(signal)).length;\n}\n\nfunction estimateRoleType(builder, maintainer) {\n  const ratio = builder / Math.max(1, maintainer);\n  if (ratio >= 2) return 'likely_builder';\n  if (ratio >= 1) return 'hybrid';\n  if (ratio >= 0.5) return 'leaning_maintainer';\n  return 'likely_maintainer';\n}\n\nconst jobData = $json;\n\n// Skip empty items\nif (jobData._empty) {\n  return { json: { ...jobData, _skip: true } };\n}\n\nconst title = (jobData['Job Title'] || '').toLowerCase();\nconst text = title;\n\n// Count signals from title only\nconst builderCount = countSignals(text, BUILDER_SIGNALS);\nconst maintainerCount = countSignals(text, MAINTAINER_SIGNALS);\n\n// Check title exclusions\nconst hasBadTitle = TITLE_EXCLUDES.some(exc => title.includes(exc));\n\n// Check seniority\nconst hasSeniority = CONFIG.seniorityRequired.some(level => title.includes(level));\n\n// Decision logic - since we only have title, be more permissive\nlet shouldProcess = true;\nlet reason = null;\n\n// Only hard reject obvious IC titles without seniority\nif (hasBadTitle && !hasSeniority) {\n  shouldProcess = false;\n  reason = `IC title (${title}) without leadership level`;\n}\n\nconst prefilterAnalysis = {\n  shouldProcess,\n  reason,\n  builderSignals: builderCount,\n  maintainerSignals: maintainerCount,\n  signalRatio: builderCount / Math.max(1, maintainerCount),\n  hasSeniority,\n  estimatedRoleType: estimateRoleType(builderCount, maintainerCount)\n};\n\nreturn {\n  json: {\n    ...jobData,\n    prefilterAnalysis\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-2400, -176],
      "id": "prefilter-waas-001",
      "name": "Prefilter: Builder vs Maintainer"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.prefilterAnalysis.shouldProcess }}",
              "value2": true
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [-2208, -176],
      "id": "prefilter-if-waas-001",
      "name": "IF: Should Process"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [-2208, 32],
      "id": "skip-filtered-waas-001",
      "name": "Skip Filtered Jobs"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Rate job fit using Claude AI - Builder vs Maintainer Focus\n\ntry {\n  const job = $input.item.json;\n  const ycBatch = job['_ycBatch'] || '';\n  const scrapedIndustry = job['_scrapedIndustry'] || '';\n  const prefilterAnalysis = job.prefilterAnalysis || {};\n  \n  // Get API key from Airtable Config\n  const apiKey = $('Parse Config').first().json.ANTHROPIC_API_KEY;\n  \n  if (!apiKey) {\n    const { _ycBatch, _scrapedIndustry, prefilterAnalysis: pf, ...cleanJob } = job;\n    return { json: { ...cleanJob, 'Tide-Pool Score': 0, 'Tide-Pool Rationale': 'ANTHROPIC_API_KEY not found', 'Industry': scrapedIndustry, 'Company Stage': ycBatch, 'Role Type': '', 'Builder Evidence': '', 'Maintainer Evidence': '', 'Recommendation': '' } };\n  }\n  \n  // Comprehensive system prompt\n  const systemPrompt = `You are a job matching assistant for Eric, a Customer Success leader who thrives in the early inningsâ€”building CS functions from scratch and scaling them through hypergrowth.\n\n## Eric's Background\n- Built Bigtincan's entire CS organization from first support hire to 25 people across 3 regions with 24/7 coverage over 9 years\n- Scaled from scrappy startup to enterprise platform serving 250+ Fortune 1000 accounts\n- Designed escalation frameworks, implemented tooling (Salesforce Service Cloud, Zendesk, Jira), created health-based prioritization systems\n- Previously at Apperian: built support infrastructure scaling to 60 enterprise accounts and 20K+ users before acquisition\n\n## What Eric Is Looking For\nEric wants to build, not maintain. He's looking for:\n- Series A/B companies where customer success is still taking shape\n- Organizations that need someone who can own the queue on Monday, redesign the onboarding workflow on Tuesday, and present retention metrics to the exec team on Wednesday\n- Environments where CS is treated as a growth lever, not a cost center\n- The messy, ambiguous stage where there's no playbook yet\n\n## Critical Distinction: BUILDER vs MAINTAINER\n\n**BUILDER ROLE (what Eric wants):**\n- Building CS/Support function from scratch or early stage\n- Defining processes, creating playbooks\n- First or early CS hire, founding team\n- Series A/B, startup, hypergrowth environment\n- Wearing multiple hats, player-coach\n- Strategic voice of customer to product/leadership\n- Hiring and scaling a team\n\n**MAINTAINER ROLE (not a fit):**\n- Managing existing book of business/portfolio of accounts\n- Hitting established retention/renewal targets\n- Mature organization with proven playbooks\n- Individual contributor CSM work (even if senior)\n- Narrow focus on NRR/GRR/churn metrics without building\n- Cost center mentality\n\n## Scoring Rules\n\n### AUTOMATIC ZERO SCORE (Dealbreakers)\nScore MUST be 0 if ANY of these are true:\n- Role is clearly MAINTAINER type (managing book of business, not building)\n- Individual contributor CSM role (not leadership/building)\n- Company has 500+ employees AND role isn't explicitly building new function\n- Base salary below $125,000 (if disclosed)\n- Requires relocation (Eric is in Providence, RI - remote or Boston hybrid OK)\n- Industry is defense, gambling, tobacco, or weapons\n\n### SCORING WEIGHTS (100 points total)\n\n**Builder vs Maintainer Signal (40 points)**\n- 40: Explicitly building from scratch, first CS hire, greenfield\n- 30: Early-stage function, significant building required, player-coach\n- 20: Mix of building and maintaining, growth mode\n- 10: Mostly maintaining but some strategic/building elements\n- 0: Pure maintenance, book of business management\n\n**Company Stage & Size (25 points)**\n- 25: Series A/B, <100 employees, startup environment\n- 20: Series C or 100-200 employees, still growing fast\n- 15: 200-500 employees but explicitly building new CS function\n- 10: Larger company but new division/product needing CS buildout\n- 0: 500+ mature company, established CS org\n\n**Role Scope & Level (20 points)**\n- 20: VP/Head of, building and leading team, exec visibility\n- 15: Director level, significant ownership and building\n- 10: Senior Manager/Lead with builder responsibilities\n- 5: Manager level with some building\n- 0: Individual contributor or purely operational\n\n**Compensation & Equity (10 points)**\n- 10: Base $150K+, meaningful equity\n- 8: Base $125-150K with equity\n- 5: Base $125K+ without equity, or equity but lower base\n- 2: Salary unclear but strong builder signals\n- 0: Base clearly below $100K\n\n**Mission & Domain Fit (5 points)**\n- 5: Enterprise SaaS, healthcare tech, life sciences, AI platforms\n- 3: Adjacent interesting domain\n- 1: Neutral domain\n- 0: Misaligned domain\n\n## Response Format\n\nRespond with ONLY valid JSON:\n{\n  \"score\": <0-100>,\n  \"role_type\": \"builder\" | \"maintainer\" | \"hybrid\",\n  \"is_dealbreaker\": <true/false>,\n  \"dealbreaker_reason\": \"<reason if dealbreaker, null otherwise>\",\n  \"industry\": \"<company's industry>\",\n  \"company_stage_detected\": \"<seed|series_a|series_b|series_c|growth|mature|unknown>\",\n  \"builder_evidence\": [<signals suggesting builder role>],\n  \"maintainer_evidence\": [<signals suggesting maintainer role>],\n  \"recommendation\": \"apply\" | \"research\" | \"skip\",\n  \"summary\": \"<2-3 sentence assessment focused on builder vs maintainer fit>\"\n}`;\n\n  const prefilterInfo = prefilterAnalysis.estimatedRoleType ? \n    `\\n\\nPREFILTER ANALYSIS:\\n- Estimated role type: ${prefilterAnalysis.estimatedRoleType}\\n- Has seniority: ${prefilterAnalysis.hasSeniority}` : '';\n\n  const userPrompt = `Analyze this job posting for Eric.\n\nREMINDER - Eric's criteria:\n- BUILDER roles, not MAINTAINER (key distinction)\n- Series A/B companies, <100-200 employees ideal\n- Building CS function from scratch or early stage\n- Leadership level (VP/Director/Head of)\n- $125K+ base, equity preferred\n- Remote or Boston-area hybrid\n- Domains: Enterprise SaaS, healthcare tech, life sciences, AI${prefilterInfo}\n\nJOB POSTING:\nTitle: ${job['Job Title']}\nCompany: ${job['Company']}\nLocation: ${job['Location']}\nSalary: ${job['Salary Info']}\nSource: ${job['Source']}\nYC Batch: ${ycBatch}\n\nNote: This is a YC startup. Analyze based on title and any company context you know.\n\nReturn JSON only.`;\n\n  const data = await this.helpers.httpRequest({\n    method: 'POST',\n    url: 'https://api.anthropic.com/v1/messages',\n    headers: {\n      'Content-Type': 'application/json',\n      'x-api-key': apiKey,\n      'anthropic-version': '2023-06-01'\n    },\n    body: {\n      model: 'claude-3-haiku-20240307',\n      max_tokens: 1500,\n      system: systemPrompt,\n      messages: [{ role: 'user', content: userPrompt }]\n    },\n    json: true\n  });\n  \n  const responseText = data.content?.[0]?.text || '{}';\n  let parsed;\n  try {\n    const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\n    parsed = jsonMatch ? JSON.parse(jsonMatch[0]) : { score: 0, summary: 'Could not parse response' };\n  } catch (e) {\n    parsed = { score: 0, summary: 'JSON parse error: ' + e.message };\n  }\n  \n  // Extract fields\n  const fitScore = parsed.score || 0;\n  const roleType = parsed.role_type || '';\n  const recommendation = parsed.recommendation || '';\n  let fitRationale = parsed.summary || 'No summary';\n  \n  if (parsed.is_dealbreaker && parsed.dealbreaker_reason) {\n    fitRationale = `DEALBREAKER: ${parsed.dealbreaker_reason}. ${fitRationale}`;\n  }\n  \n  const finalIndustry = parsed.industry || scrapedIndustry || '';\n  const finalStage = parsed.company_stage_detected || ycBatch || '';\n  \n  const builderEvidence = (parsed.builder_evidence || []).slice(0, 3).join('; ');\n  const maintainerEvidence = (parsed.maintainer_evidence || []).slice(0, 3).join('; ');\n  \n  // Remove internal fields\n  const { _ycBatch, _scrapedIndustry, prefilterAnalysis: pf, ...cleanJob } = job;\n  \n  return {\n    json: {\n      ...cleanJob,\n      'Tide-Pool Score': fitScore,\n      'Tide-Pool Rationale': fitRationale,\n      'Industry': finalIndustry,\n      'Company Stage': finalStage,\n      'Role Type': roleType,\n      'Builder Evidence': builderEvidence,\n      'Maintainer Evidence': maintainerEvidence,\n      'Recommendation': recommendation\n    }\n  };\n} catch (error) {\n  const job = $input.item.json;\n  const ycBatch = job['_ycBatch'] || '';\n  const scrapedIndustry = job['_scrapedIndustry'] || '';\n  const { _ycBatch, _scrapedIndustry, prefilterAnalysis, ...cleanJob } = job;\n  return {\n    json: {\n      ...cleanJob,\n      'Tide-Pool Score': 0,\n      'Tide-Pool Rationale': 'Error: ' + error.message,\n      'Industry': scrapedIndustry,\n      'Company Stage': ycBatch,\n      'Role Type': '',\n      'Builder Evidence': '',\n      'Maintainer Evidence': '',\n      'Recommendation': ''\n    }\n  };\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-2016, -176],
      "id": "3a7d00d7-3393-48af-b112-35a932a6280e",
      "name": "Rate Job Fit"
    },
    {
      "parameters": {
        "authentication": "airtableTokenApi",
        "operation": "append",
        "application": "appFEzXvPWvRtXgRY",
        "table": "tbl6ZV2rHjWz56pP3",
        "addAllFields": false,
        "fields": [
          "Job Title",
          "Company",
          "Location",
          "Source",
          "Job URL",
          "Job ID",
          "Salary Info",
          "Date Found",
          "Review Status",
          "Tide-Pool Score",
          "Tide-Pool Rationale",
          "Industry",
          "Company Stage",
          "Role Type",
          "Builder Evidence",
          "Maintainer Evidence",
          "Recommendation"
        ],
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 1,
      "position": [-1824, -176],
      "id": "a83377ee-cd9e-406b-b867-7d731e12203b",
      "name": "Add to Airtable"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [-2592, 128],
      "id": "96ef8a28-14a9-48f1-9b94-4773adb2c904",
      "name": "No Jobs/Error"
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Get Config",
            "type": "main",
            "index": 0
          },
          {
            "node": "Search Existing Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Config": {
      "main": [
        [
          {
            "node": "Parse Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Config": {
      "main": [
        [
          {
            "node": "Scrape via Browserless",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Scrape via Browserless": {
      "main": [
        [
          {
            "node": "Parse & Filter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse & Filter": {
      "main": [
        [
          {
            "node": "Merge for Dedup",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search Existing Jobs": {
      "main": [
        [
          {
            "node": "Merge for Dedup",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge for Dedup": {
      "main": [
        [
          {
            "node": "Dedup Against Airtable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dedup Against Airtable": {
      "main": [
        [
          {
            "node": "Has Jobs?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Jobs?": {
      "main": [
        [
          {
            "node": "Prefilter: Builder vs Maintainer",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Jobs/Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prefilter: Builder vs Maintainer": {
      "main": [
        [
          {
            "node": "IF: Should Process",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF: Should Process": {
      "main": [
        [
          {
            "node": "Rate Job Fit",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip Filtered Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rate Job Fit": {
      "main": [
        [
          {
            "node": "Add to Airtable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "tags": []
}
