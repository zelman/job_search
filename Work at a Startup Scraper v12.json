{
  "name": "Work at a Startup Scraper v12",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 6
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.3,
      "position": [
        -4000,
        -80
      ],
      "id": "07904d1d-5321-4561-9c5f-2f56c567ece6",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "value": "appFEzXvPWvRtXgRY",
          "mode": "id"
        },
        "table": {
          "__rl": true,
          "value": "tblofzQpzGEN8igVS",
          "mode": "id"
        },
        "filterByFormula": "OR({Key} = 'YC_USER', {Key} = 'YC_PASSWORD', {Key} = 'BROWSERLESS_TOKEN')",
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        -3792,
        -176
      ],
      "id": "4245412e-f535-4750-ad72-5d9fdf3a7536",
      "name": "Get Config"
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "value": "appFEzXvPWvRtXgRY",
          "mode": "id"
        },
        "table": {
          "__rl": true,
          "value": "tbl6ZV2rHjWz56pP3",
          "mode": "id"
        },
        "filterByFormula": "IS_AFTER({Date Found}, DATEADD(TODAY(), -30, 'days'))",
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        -3792,
        32
      ],
      "id": "59457566-725e-4f7a-a8f2-aa5465179599",
      "name": "Search Existing Jobs"
    },
    {
      "parameters": {
        "jsCode": "// Extract config values\nconst items = $input.all();\nconst config = {};\n\nfor (const item of items) {\n  const key = item.json.fields?.Key || item.json.Key;\n  const value = item.json.fields?.Value || item.json.Value;\n  if (key && value) {\n    config[key] = value;\n  }\n}\n\nreturn [{ json: config }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3600,
        -176
      ],
      "id": "91c8c24f-12f1-4306-b584-9f92d92399ac",
      "name": "Parse Config"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://chrome.browserless.io/function?token={{ $json.BROWSERLESS_TOKEN }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ context: { ycUser: $json.YC_USER, ycPassword: $json.YC_PASSWORD }, code: String.raw`export default async ({ page, context }) => { const { ycUser, ycPassword } = context; const jobsUrl = 'https://www.workatastartup.com/companies?demographic=any&hasEquity=any&hasSalary=any&industry=any&interviewProcess=any&jobType=any&layout=list-compact&role=support&sortBy=keyword&tab=any&usVisaNotRequired=any'; const sleep = ms => new Promise(r => setTimeout(r, ms)); try { page.setDefaultTimeout(60000); await page.goto('https://www.workatastartup.com/', { waitUntil: 'networkidle2', timeout: 30000 }); await sleep(2000); const needsLogin = await page.evaluate(() => !document.cookie.includes('_sso_session')); if (needsLogin) { await page.goto('https://account.ycombinator.com/authenticate?continue=' + encodeURIComponent(jobsUrl), { waitUntil: 'networkidle2', timeout: 30000 }); await sleep(2000); const hasLoginForm = await page.$('#ycid-input'); if (hasLoginForm) { await page.type('#ycid-input', ycUser, { delay: 30 }); await sleep(500); await page.type('#password-input', ycPassword, { delay: 30 }); await sleep(500); await Promise.all([ page.click('button[type=\"submit\"]'), page.waitForNavigation({ waitUntil: 'networkidle2', timeout: 30000 }).catch(() => {}) ]); await sleep(3000); } } await page.goto(jobsUrl, { waitUntil: 'networkidle2', timeout: 45000 }); await sleep(3000); await page.waitForSelector('body', { timeout: 10000 }); for (let i = 0; i < 5; i++) { await page.evaluate(() => { if (document.body) window.scrollTo(0, document.body.scrollHeight); }); await sleep(2000); } const jobs = await page.evaluate(() => { const results = []; const seen = new Set(); const extractCompanyBatch = (text) => { if (!text || text.includes('See all') || text.includes('jobs ›')) return null; const batchMatch = text.match(/([A-Za-z0-9][A-Za-z0-9 &.,'-]+?)\\s*\\(([SWF]\\d{2})\\)/); if (batchMatch) { return { company: batchMatch[1].trim(), batch: 'YC ' + batchMatch[2] }; } return null; }; document.querySelectorAll('a[href*=\"/jobs/\"]').forEach(jobLink => { const href = jobLink.getAttribute('href'); if (!href || seen.has(href)) return; seen.add(href); const url = href.startsWith('http') ? href : 'https://www.workatastartup.com' + href; const title = jobLink.innerText.trim(); let company = 'Unknown'; let location = 'Not specified'; let ycBatch = '';  let el = jobLink; for (let i = 0; i < 15 && el; i++) { el = el.parentElement; if (!el) break; const companyLinks = el.querySelectorAll('a[href*=\"/companies/\"]'); for (const companyLink of companyLinks) { const companyText = companyLink.innerText.trim(); if (companyText && !companyText.includes('See all') && !companyText.includes('jobs ›') && companyText.length > 1 && companyText.length < 100) { const extracted = extractCompanyBatch(companyText); if (extracted) { company = extracted.company; ycBatch = extracted.batch; } else { company = companyText.split('•')[0].split('\\n')[0].trim(); } break; } } if (company !== 'Unknown') break; } let container = jobLink.closest('div'); for (let i = 0; i < 8 && container; i++) { const text = container.innerText || ''; const locPatterns = ['Remote', 'San Francisco', 'New York', 'Boston', 'Los Angeles', 'Seattle', 'Austin', 'Chicago', 'Denver', 'Miami', 'London', 'Berlin', 'Toronto', 'Hybrid', 'United States', 'US only']; for (const loc of locPatterns) { if (text.includes(loc)) { location = loc; break; } } if (location !== 'Not specified') break; container = container.parentElement; } if (title && title.length > 3) { results.push({ title, company, location, url, ycBatch, jobId: 'waas-' + Date.now() + '-' + results.length }); } }); return results; }); return { type: 'application/json', data: jobs, debug: { url: page.url(), jobCount: jobs.length } }; } catch (error) { return { type: 'application/json', data: [{ error: error.message, stack: error.stack }] }; } };` }) }}",
        "options": {
          "timeout": 120000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -3392,
        -176
      ],
      "id": "4d764b08-9a1b-4b70-8f2c-36d660c3e0c0",
      "name": "Scrape via Browserless"
    },
    {
      "parameters": {
        "jsCode": "// Parse Browserless response and filter jobs\nconst response = $input.first().json;\n\nlet jobs = [];\nif (response.data && response.data.jobs) {\n  jobs = response.data.jobs;\n} else if (response.data && Array.isArray(response.data)) {\n  jobs = response.data;\n} else if (Array.isArray(response)) {\n  jobs = response;\n} else if (response.error) {\n  return [{ json: { error: response.error } }];\n}\n\n// Filter for support/success leadership roles\nconst supportKeywords = ['support', 'success', 'customer', 'client', 'cx', 'experience'];\nconst leadershipKeywords = ['manager', 'director', 'vp', 'vice president', 'head', 'lead', 'chief', 'supervisor', 'team lead'];\n\nconst filteredJobs = jobs.filter(job => {\n  if (job.error) return false;\n  const title = (job.title || '').toLowerCase();\n  const hasSupport = supportKeywords.some(kw => title.includes(kw));\n  const hasLeadership = leadershipKeywords.some(kw => title.includes(kw));\n  return hasSupport && hasLeadership;\n});\n\nif (filteredJobs.length === 0) {\n  return [{ json: { _empty: true, _rawCount: jobs.length, _message: 'No jobs matched both support AND leadership keywords' } }];\n}\n\nreturn filteredJobs.map(job => ({\n  json: {\n    \"Job Title\": job.title,\n    \"Company\": job.company,\n    \"Location\": job.location || 'Not specified',\n    \"Source\": 'Work at a Startup',\n    \"Job URL\": job.url,\n    \"Job ID\": job.jobId,\n    \"Salary Info\": job.salary || 'Not specified',\n    \"Date Found\": new Date().toISOString().split('T')[0],\n    \"Review Status\": \"New\",\n    \"_ycBatch\": job.ycBatch || '',\n    \"_scrapedIndustry\": job.industry || ''\n  }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3200,
        -176
      ],
      "id": "f8264261-5d7f-417c-be45-f342230e9d90",
      "name": "Parse & Filter YC"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://chrome.browserless.io/function?token={{ $json.BROWSERLESS_TOKEN }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ code: `export default async ({ page }) => { const sleep = ms => new Promise(r => setTimeout(r, ms)); try { page.setDefaultTimeout(60000); await page.goto('https://jobs.costanoa.vc/jobs?staffCountRanges=1-10&staffCountRanges=10-100', { waitUntil: 'networkidle2', timeout: 45000 }); await sleep(3000); const data = await page.evaluate(() => { if (window.serverInitialData) { return { serverData: window.serverInitialData }; } const scripts = document.querySelectorAll('script'); for (const script of scripts) { const text = script.textContent || ''; if (text.includes('serverInitialData')) { const match = text.match(/window\\\\.serverInitialData\\\\s*=\\\\s*(\\\\{[\\\\s\\\\S]*?\\\\});/); if (match) { try { return { serverData: JSON.parse(match[1]) }; } catch (e) {} } } } return { error: 'No serverInitialData found', html: document.body.innerHTML.substring(0, 5000) }; }); return { type: 'application/json', data }; } catch (error) { return { type: 'application/json', data: { error: error.message } }; } };` }) }}",
        "options": {
          "timeout": 120000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -3392,
        100
      ],
      "id": "costanoa-scrape-001",
      "name": "Scrape Costanoa"
    },
    {
      "parameters": {
        "jsCode": "// Parse Costanoa jobs from Consider platform serverInitialData\nconst response = $input.first().json;\n\nlet jobs = [];\n\ntry {\n  const data = response.data?.serverData || response.serverData;\n  \n  if (!data) {\n    return [{ json: { _empty: true, _message: 'No serverInitialData found', _error: response.data?.error } }];\n  }\n  \n  // Consider platform stores jobs in data.jobs or data.initialData.jobs\n  const rawJobs = data.jobs || data.initialData?.jobs || [];\n  const companies = data.companies || data.initialData?.companies || {};\n  \n  // Filter for support/success leadership roles\n  const supportKeywords = ['support', 'success', 'customer', 'client', 'cx', 'experience'];\n  const leadershipKeywords = ['manager', 'director', 'vp', 'vice president', 'head', 'lead', 'chief', 'supervisor', 'team lead'];\n  \n  for (const job of rawJobs) {\n    const title = (job.title || '').toLowerCase();\n    const hasSupport = supportKeywords.some(kw => title.includes(kw));\n    const hasLeadership = leadershipKeywords.some(kw => title.includes(kw));\n    \n    if (hasSupport && hasLeadership) {\n      // Get company info\n      const company = companies[job.companyId] || {};\n      const companyName = company.name || job.companyName || 'Unknown';\n      \n      // Build job URL\n      const jobSlug = job.slug || job.id;\n      const jobUrl = `https://jobs.costanoa.vc/jobs/${jobSlug}`;\n      \n      // Location\n      let location = 'Not specified';\n      if (job.locations && job.locations.length > 0) {\n        location = job.locations.map(l => l.name || l).join(', ');\n      } else if (job.location) {\n        location = job.location;\n      } else if (job.remote) {\n        location = 'Remote';\n      }\n      \n      // Salary\n      let salary = 'Not specified';\n      if (job.compensationMin || job.compensationMax) {\n        const min = job.compensationMin ? `$${(job.compensationMin/1000).toFixed(0)}K` : '';\n        const max = job.compensationMax ? `$${(job.compensationMax/1000).toFixed(0)}K` : '';\n        salary = min && max ? `${min} - ${max}` : (min || max);\n      } else if (job.salary) {\n        salary = job.salary;\n      }\n      \n      jobs.push({\n        json: {\n          \"Job Title\": job.title,\n          \"Company\": companyName,\n          \"Location\": location,\n          \"Source\": \"Costanoa VC\",\n          \"Job URL\": jobUrl,\n          \"Job ID\": `costanoa-${job.id || Date.now()}-${jobs.length}`,\n          \"Salary Info\": salary,\n          \"Date Found\": new Date().toISOString().split('T')[0],\n          \"Review Status\": \"New\",\n          \"_ycBatch\": company.funding || '',\n          \"_scrapedIndustry\": company.industry || job.industry || ''\n        }\n      });\n    }\n  }\n  \n  if (jobs.length === 0) {\n    return [{ json: { _empty: true, _rawCount: rawJobs.length, _message: 'No Costanoa jobs matched support AND leadership keywords' } }];\n  }\n  \n  return jobs;\n} catch (error) {\n  return [{ json: { _empty: true, _error: error.message } }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3200,
        100
      ],
      "id": "costanoa-parse-001",
      "name": "Parse Costanoa Jobs"
    },
    {
      "parameters": {
        "mode": "append"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -3000,
        -40
      ],
      "id": "merge-job-sources-001",
      "name": "Merge Job Sources"
    },
    {
      "parameters": {
        "mode": "append"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -2900,
        -80
      ],
      "id": "9b40d2ad-c5cc-45d4-8820-d14cc4a8436a",
      "name": "Merge for Dedup"
    },
    {
      "parameters": {
        "jsCode": "// Dedup scraped jobs against existing Airtable records\n\nconst normalize = (str) => {\n  if (!str) return '';\n  return str.toLowerCase().replace(/[^a-z0-9]/g, '').trim();\n};\n\nconst allItems = $input.all();\n\n// Valid sources for new jobs\nconst validSources = ['Work at a Startup', 'Costanoa VC'];\n\n// Separate new jobs from existing Airtable records\nconst newJobs = allItems.filter(item => \n  item.json['Job Title'] && validSources.includes(item.json['Source']) && !item.json.fields\n);\n\nconst existingRecords = allItems.filter(item => \n  item.json.fields || (item.json['Job URL'] && !item.json['_ycBatch'] && !validSources.includes(item.json['Source']))\n);\n\n// Build sets of existing URLs and normalized title+company keys\nconst existingUrls = new Set();\nconst existingKeys = new Set();\n\nfor (const item of existingRecords) {\n  const fields = item.json.fields || item.json;\n  \n  // Add URL (normalized - remove trailing slashes, params)\n  let url = fields['Job URL'] || '';\n  if (url) {\n    url = url.split('?')[0].replace(/\\/$/, '');\n    existingUrls.add(url);\n  }\n  \n  // Add normalized title+company key\n  const title = normalize(fields['Job Title'] || '');\n  const company = normalize(fields['Company'] || '');\n  if (title && company) {\n    existingKeys.add(title + '|' + company);\n  }\n}\n\n// Filter new jobs against existing\nconst results = [];\nconst addedUrls = new Set();\nconst addedKeys = new Set();\n\nfor (const job of newJobs) {\n  // Skip empty markers\n  if (job.json._empty) continue;\n  \n  // Normalize URL\n  let url = job.json['Job URL'] || '';\n  if (url) {\n    url = url.split('?')[0].replace(/\\/$/, '');\n  }\n  \n  // Normalize title and company\n  const title = normalize(job.json['Job Title'] || '');\n  const company = normalize(job.json['Company'] || '');\n  const key = title + '|' + company;\n  \n  // Skip if URL already exists in Airtable or this batch\n  if (url && (existingUrls.has(url) || addedUrls.has(url))) continue;\n  \n  // Skip if title+company combo exists\n  if (existingKeys.has(key) || addedKeys.has(key)) continue;\n  \n  // Add to tracking sets\n  if (url) addedUrls.add(url);\n  addedKeys.add(key);\n  \n  results.push(job);\n}\n\nreturn results.length ? results : [{ json: { _empty: true } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2700,
        -80
      ],
      "id": "1495d51c-c224-44e5-adb5-db5701d3d35d",
      "name": "Dedup Against Airtable"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json._empty }}",
              "operation": "notEqual",
              "value2": true
            },
            {
              "value1": "={{ $json.error }}",
              "operation": "isEmpty"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -2592,
        -80
      ],
      "id": "601b7f43-cb8d-44b3-aab6-65054524cb51",
      "name": "Has Jobs?"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Builder vs Maintainer Pre-Filter\n// Quick signal check before expensive LLM calls\n\nconst CONFIG = {\n  minBuilderSignals: 1,\n  maxMaintainerSignals: 3,\n  maxCompanySize: 500,\n  seniorityRequired: [\"head\", \"director\", \"vp\", \"vice president\", \"chief\", \"lead\"],\n  minBaseSalary: 125000,\n};\n\nconst BUILDER_SIGNALS = [\n  \"build from scratch\", \"building the function\", \"first hire\", \"founding team\",\n  \"ground floor\", \"greenfield\", \"no playbook\", \"define the playbook\",\n  \"create the playbook\", \"build the team\", \"stand up\", \"establish the foundation\",\n  \"series a\", \"series b\", \"seed stage\", \"early stage\", \"early-stage\",\n  \"startup\", \"hypergrowth\", \"wear many hats\", \"player-coach\", \"hands-on leader\",\n  \"roll up your sleeves\", \"scrappy\", \"ambiguity\", \"build processes\",\n  \"define processes\", \"voice of customer\", \"growth lever\", \"strategic partner\",\n  \"report to ceo\", \"report to founder\", \"exec team\"\n];\n\nconst MAINTAINER_SIGNALS = [\n  \"book of business\", \"portfolio of accounts\", \"manage your accounts\",\n  \"own a portfolio\", \"retention targets\", \"renewal rate\", \"net retention\",\n  \"gross retention\", \"nrr\", \"grr\", \"churn reduction\", \"upsell quota\",\n  \"expansion targets\", \"expansion revenue\", \"cross-sell\", \"established processes\",\n  \"proven playbook\", \"existing team of\", \"maintain existing\", \"support the team\",\n  \"customer success manager\", \"manage relationships\", \"own the relationship\",\n  \"point of contact for\"\n];\n\nconst TITLE_EXCLUDES = [\n  \"customer success manager\", \"csm\", \"account manager\", \"account executive\",\n  \"representative\", \"specialist\", \"associate\", \"coordinator\", \"analyst\"\n];\n\nfunction countSignals(text, signals) {\n  return signals.filter(signal => text.includes(signal)).length;\n}\n\nfunction estimateRoleType(builder, maintainer) {\n  const ratio = builder / Math.max(1, maintainer);\n  if (ratio >= 2) return 'likely_builder';\n  if (ratio >= 1) return 'hybrid';\n  if (ratio >= 0.5) return 'leaning_maintainer';\n  return 'likely_maintainer';\n}\n\nconst jobData = $json;\n\n// Skip empty items\nif (jobData._empty) {\n  return { json: { ...jobData, _skip: true } };\n}\n\nconst title = (jobData['Job Title'] || '').toLowerCase();\nconst text = title;\n\n// Count signals from title only\nconst builderCount = countSignals(text, BUILDER_SIGNALS);\nconst maintainerCount = countSignals(text, MAINTAINER_SIGNALS);\n\n// Check title exclusions\nconst hasBadTitle = TITLE_EXCLUDES.some(exc => title.includes(exc));\n\n// Check seniority\nconst hasSeniority = CONFIG.seniorityRequired.some(level => title.includes(level));\n\n// Decision logic - since we only have title, be more permissive\nlet shouldProcess = true;\nlet reason = null;\n\n// Only hard reject obvious IC titles without seniority\nif (hasBadTitle && !hasSeniority) {\n  shouldProcess = false;\n  reason = `IC title (${title}) without leadership level`;\n}\n\nconst prefilterAnalysis = {\n  shouldProcess,\n  reason,\n  builderSignals: builderCount,\n  maintainerSignals: maintainerCount,\n  signalRatio: builderCount / Math.max(1, maintainerCount),\n  hasSeniority,\n  estimatedRoleType: estimateRoleType(builderCount, maintainerCount)\n};\n\nreturn {\n  json: {\n    ...jobData,\n    prefilterAnalysis\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2400,
        -176
      ],
      "id": "prefilter-waas-001",
      "name": "Prefilter: Builder vs Maintainer"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.prefilterAnalysis.shouldProcess }}",
              "value2": true
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -2208,
        -176
      ],
      "id": "prefilter-if-waas-001",
      "name": "IF: Should Process"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -2208,
        32
      ],
      "id": "skip-filtered-waas-001",
      "name": "Skip Filtered Jobs"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -2592,
        128
      ],
      "id": "96ef8a28-14a9-48f1-9b94-4773adb2c904",
      "name": "No Jobs/Error"
    },
    {
      "parameters": {
        "source": "database",
        "workflowId": {
          "__rl": true,
          "value": "v24qHkIsp8GVCwFkscHP8",
          "mode": "id"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        -2016,
        -176
      ],
      "id": "waas-exec-job-pipeline",
      "name": "Execute Job Evaluation Pipeline",
      "notes": "Calls shared subworkflow for enrichment, evaluation, and Airtable write"
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Get Config",
            "type": "main",
            "index": 0
          },
          {
            "node": "Search Existing Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Config": {
      "main": [
        [
          {
            "node": "Parse Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Config": {
      "main": [
        [
          {
            "node": "Scrape via Browserless",
            "type": "main",
            "index": 0
          },
          {
            "node": "Scrape Costanoa",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Scrape via Browserless": {
      "main": [
        [
          {
            "node": "Parse & Filter YC",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse & Filter YC": {
      "main": [
        [
          {
            "node": "Merge Job Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Scrape Costanoa": {
      "main": [
        [
          {
            "node": "Parse Costanoa Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Costanoa Jobs": {
      "main": [
        [
          {
            "node": "Merge Job Sources",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Job Sources": {
      "main": [
        [
          {
            "node": "Merge for Dedup",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search Existing Jobs": {
      "main": [
        [
          {
            "node": "Merge for Dedup",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge for Dedup": {
      "main": [
        [
          {
            "node": "Dedup Against Airtable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dedup Against Airtable": {
      "main": [
        [
          {
            "node": "Has Jobs?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Jobs?": {
      "main": [
        [
          {
            "node": "Prefilter: Builder vs Maintainer",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Jobs/Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prefilter: Builder vs Maintainer": {
      "main": [
        [
          {
            "node": "IF: Should Process",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF: Should Process": {
      "main": [
        [
          {
            "node": "Execute Job Evaluation Pipeline",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip Filtered Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "tags": []
}
